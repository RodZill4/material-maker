{
	"name": "fbm",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"folds": 0,
		"iterations": 5,
		"noise": 0,
		"persistence": 0.5,
		"scale_x": 2,
		"scale_y": 2
	},
	"seed_int": 0,
	"shader_model": {
		"code": "",
		"global": [
			"float oldfbm_value(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat p00 = rand(mod(o, size));",
			"\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));",
			"\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));",
			"\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));",
			"\tvec2 t = f * f * (3.0 - 2.0 * f);",
			"\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);",
			"}",
			"",
			"float oldfbm_perlin(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat a00 = rand(mod(o, size)) * 6.28318530718;",
			"\tfloat a01 = rand(mod(o + vec2(0.0, 1.0), size)) * 6.28318530718;",
			"\tfloat a10 = rand(mod(o + vec2(1.0, 0.0), size)) * 6.28318530718;",
			"\tfloat a11 = rand(mod(o + vec2(1.0, 1.0), size)) * 6.28318530718;",
			"\tvec2 v00 = vec2(cos(a00), sin(a00));",
			"\tvec2 v01 = vec2(cos(a01), sin(a01));",
			"\tvec2 v10 = vec2(cos(a10), sin(a10));",
			"\tvec2 v11 = vec2(cos(a11), sin(a11));",
			"\tfloat p00 = dot(v00, f);",
			"\tfloat p01 = dot(v01, f - vec2(0.0, 1.0));",
			"\tfloat p10 = dot(v10, f - vec2(1.0, 0.0));",
			"\tfloat p11 = dot(v11, f - vec2(1.0, 1.0));",
			"\tvec2 t = f * f * (3.0 - 2.0 * f);",
			"\treturn 0.5 + mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);",
			"}",
			"",
			"float oldfbm_perlinabs(vec2 coord, vec2 size, float seed) {",
			"\treturn abs(2.0*oldfbm_perlin(coord, size, seed)-1.0);",
			"}",
			"",
			"float oldfbm_cellular(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float oldfbm_cellular2(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			"",
			"float oldfbm_cellular3(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);",
			"\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float oldfbm_cellular4(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);",
			"\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			"",
			"float oldfbm_cellular5(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float oldfbm_cellular6(vec2 coord, vec2 size, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			""
		],
		"inputs": [

		],
		"instance": [
			"float $(name)_fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = oldfbm_$noise(coord*size, size, seed);",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			""
		],
		"longdesc": "Generates a noise made of several octaves of a simple noise",
		"name": "FBM",
		"outputs": [
			{
				"f": "$(name)_fbm($(uv), vec2($(scale_x), $(scale_y)), int($(folds)), int($(iterations)), $(persistence), float($(seed)))",
				"longdesc": "Shows a grayscale image of the generated noise",
				"shortdesc": "Output",
				"type": "f"
			}
		],
		"parameters": [
			{
				"default": 0,
				"label": "Noise",
				"longdesc": "The simple noise type",
				"name": "noise",
				"shortdesc": "Noise type",
				"type": "enum",
				"values": [
					{
						"name": "Value",
						"value": "value"
					},
					{
						"name": "Perlin",
						"value": "perlin"
					},
					{
						"name": "Cellular",
						"value": "cellular"
					},
					{
						"name": "Cellular 2",
						"value": "cellular2"
					},
					{
						"name": "Cellular 3",
						"value": "cellular3"
					},
					{
						"name": "Cellular 4",
						"value": "cellular4"
					},
					{
						"name": "Cellular 5",
						"value": "cellular5"
					},
					{
						"name": "Cellular 6",
						"value": "cellular6"
					}
				]
			},
			{
				"control": "None",
				"default": 4,
				"label": "Scale X",
				"longdesc": "The scale of the first octave along the X axis",
				"max": 32,
				"min": 1,
				"name": "scale_x",
				"shortdesc": "Scale.x",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 4,
				"label": "Scale Y",
				"longdesc": "The scale of the first octave along the Y axis",
				"max": 32,
				"min": 1,
				"name": "scale_y",
				"shortdesc": "Scale.y",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0,
				"label": "Folds",
				"longdesc": "The number of times the basic noise is folded",
				"max": 5,
				"min": 0,
				"name": "folds",
				"shortdesc": "Folds",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 3,
				"label": "Iterations",
				"longdesc": "The number of noise octaves",
				"max": 10,
				"min": 1,
				"name": "iterations",
				"shortdesc": "Octaves",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.5,
				"label": "Persistence",
				"longdesc": "The persistence between two consecutive octaves",
				"max": 1,
				"min": 0,
				"name": "persistence",
				"shortdesc": "Persistence",
				"step": 0.01,
				"type": "float"
			}
		],
		"shortdesc": "Fractional Brownian Motion Noise"
	},
	"type": "shader"
}