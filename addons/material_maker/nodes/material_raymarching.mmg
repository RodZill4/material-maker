{
	"export": {

	},
	"export_last_target": "Godot",
	"name": "material_raymarching",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"flip_y": false
	},
	"seed_int": 0,
	"shader_model": {
		"code": "",
		"custom": "",
		"exports": {
			"Godot/Godot 3": {
				"export_extension": "tres",
				"files": [
					{
						"file_name": "$(path_prefix).tres",
						"template": [
							"[gd_resource type=\"ShaderMaterial\" load_steps=2 format=2]",
							"[ext_resource path=\"$(file_prefix).gdshader\" type=\"Shader\" id=1]",
							"$begin_buffers",
							"[ext_resource path=\"$(file_prefix)_texture_$(buffer_index).png\" type=\"Texture\" id=$(expr:$(buffer_index)+1)]",
							"$end_buffers",
							"[resource]",
							"shader = ExtResource( 1 )",
							"$begin_buffers",
							"shader_param/texture_$(buffer_index) = ExtResource( $(expr:$(buffer_index)+1) )",
							"$end_buffers",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).gdshader",
						"template": [
							"shader_type spatial;",
							"uniform float seed_variation = 0.0;",
							"varying float elapsed_time;",
							"varying vec3 world_camera;",
							"varying vec3 world_position;",
							"const int MAX_STEPS = 100;",
							"const float MAX_DIST = 100.0;",
							"const float SURF_DIST = 1e-3;",
							"$definitions float_uniform_to_const,rename_buffers",
							"vec2 GetDist(vec3 p) {",
							"\tfloat _seed_variation_ = seed_variation;",
							"$begin_generate",
							"\tif ($flip_y) {",
							"\t\tp *= vec3(1.0, -1.0, 1.0);",
							"\t}",
							"$end_generate",
							"$begin_generate rename_buffers",
							"\tvec2 d = $distance(p);",
							"$end_generate",
							"\treturn d;",
							"}",
							"vec2 RayMarch(vec3 ro, vec3 rd) {",
							"\tfloat dO = 0.0;",
							"\tfloat color = 0.0;",
							"\tvec2 dS;",
							"\t",
							"\tfor (int i = 0; i < MAX_STEPS; i++) {",
							"\t\tvec3 p = ro + dO * rd;",
							"\t\tdS = GetDist(p);",
							"\t\tdO += dS.x;",
							"\t\t",
							"\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {",
							"\t\t\tcolor = dS.y;",
							"\t\t\tbreak;",
							"\t\t}",
							"\t}",
							"\treturn vec2(dO, color);",
							"}",
							"vec3 GetNormal(vec3 p) {",
							"\tvec2 e = vec2(1e-2, 0);",
							"\t",
							"\tvec3 n = GetDist(p).x - vec3(",
							"\t\tGetDist(p - e.xyy).x,",
							"\t\tGetDist(p - e.yxy).x,",
							"\t\tGetDist(p - e.yyx).x",
							"\t);",
							"\t",
							"\treturn normalize(n);",
							"}",
							"void vertex() {",
							"\telapsed_time = TIME;",
							"\tworld_position = VERTEX;",
							"\tworld_camera = (inverse(MODELVIEW_MATRIX) * vec4(0, 0, 0, 1)).xyz; //object space",
							"\t//world_camera = ( CAMERA_MATRIX  * vec4(0, 0, 0, 1)).xyz; //uncomment this to raymarch in world space",
							"}",
							"void fragment() {",
							"\tfloat _seed_variation_ = seed_variation;",
							"\tvec3 ro = world_camera;",
							"\tvec3 rd =  normalize(world_position - ro);",
							"\t",
							"\tvec2 rm  = RayMarch(ro, rd);",
							"\tfloat d = rm.x;",
							"\tif (d >= MAX_DIST) {",
							"\t\tdiscard;",
							"\t} else {",
							"\t\tvec3 p = ro + rd * d;",
							"\t\tvec3 n = GetNormal(p);",
							"$begin_generate",
							"\t\tif ($flip_y) {",
							"\t\t\tp *= vec3(1.0, -1.0, 1.0);",
							"\t\t\tn *= vec3(1.0, -1.0, 1.0);",
							"\t\t} ",
							"$end_generate",
							"$begin_generate",
							"\t\tALBEDO = $albedo(vec4(p, rm.y));",
							"\t\tROUGHNESS = $roughness(vec4(p, rm.y));",
							"\t\tMETALLIC = $metallic(vec4(p, rm.y));",
							"\t\tEMISSION = $emission(vec4(p, rm.y));",
							"$end_generate",
							"\t\tNORMAL = (INV_CAMERA_MATRIX*WORLD_MATRIX*vec4(n, 0.0)).xyz;",
							"\t}",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				],
				"name": "Godot/Godot 3"
			},
			"Godot/Godot 4": {
				"export_extension": "tres",
				"files": [
					{
						"file_name": "$(path_prefix).tres",
						"template": [
							"[gd_resource type=\"ShaderMaterial\" load_steps=2 format=2]",
							"[ext_resource path=\"$(file_prefix).gdshader\" type=\"Shader\" id=1]",
							"$begin_buffers",
							"[ext_resource path=\"$(file_prefix)_texture_$(buffer_index).png\" type=\"Texture\" id=$(expr:$(buffer_index)+1)]",
							"$end_buffers",
							"[resource]",
							"shader = ExtResource( 1 )",
							"$begin_buffers",
							"shader_param/texture_$(buffer_index) = ExtResource( $(expr:$(buffer_index)+1) )",
							"$end_buffers",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).gdshader",
						"template": [
							"shader_type spatial;",
							"uniform float seed_variation = 0.0;",
							"varying float elapsed_time;",
							"varying vec3 world_camera;",
							"varying vec3 world_position;",
							"const int MAX_STEPS = 100;",
							"const float MAX_DIST = 100.0;",
							"const float SURF_DIST = 1e-3;",
							"$definitions float_uniform_to_const,rename_buffers",
							"vec2 GetDist(vec3 p) {",
							"\tfloat _seed_variation_ = seed_variation;",
							"$begin_generate",
							"\tif ($flip_y) {",
							"\t\tp *= vec3(1.0, -1.0, 1.0);",
							"\t}",
							"$end_generate",
							"$begin_generate rename_buffers",
							"\tvec2 d = $distance(p);",
							"$end_generate",
							"\treturn d;",
							"}",
							"vec2 RayMarch(vec3 ro, vec3 rd) {",
							"\tfloat dO = 0.0;",
							"\tfloat color = 0.0;",
							"\tvec2 dS;",
							"\t",
							"\tfor (int i = 0; i < MAX_STEPS; i++) {",
							"\t\tvec3 p = ro + dO * rd;",
							"\t\tdS = GetDist(p);",
							"\t\tdO += dS.x;",
							"\t\t",
							"\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {",
							"\t\t\tcolor = dS.y;",
							"\t\t\tbreak;",
							"\t\t}",
							"\t}",
							"\treturn vec2(dO, color);",
							"}",
							"vec3 GetNormal(vec3 p) {",
							"\tvec2 e = vec2(1e-2, 0);",
							"\t",
							"\tvec3 n = GetDist(p).x - vec3(",
							"\t\tGetDist(p - e.xyy).x,",
							"\t\tGetDist(p - e.yxy).x,",
							"\t\tGetDist(p - e.yyx).x",
							"\t);",
							"\t",
							"\treturn normalize(n);",
							"}",
							"void vertex() {",
							"\telapsed_time = TIME;",
							"\tworld_position = VERTEX;",
							"\tworld_camera = (inverse(MODELVIEW_MATRIX) * vec4(0, 0, 0, 1)).xyz; //object space",
							"\t//world_camera = ( CAMERA_MATRIX  * vec4(0, 0, 0, 1)).xyz; //uncomment this to raymarch in world space",
							"}",
							"void fragment() {",
							"\tfloat _seed_variation_ = seed_variation;",
							"\tvec3 ro = world_camera;",
							"\tvec3 rd =  normalize(world_position - ro);",
							"\t",
							"\tvec2 rm  = RayMarch(ro, rd);",
							"\tfloat d = rm.x;",
							"\tif (d >= MAX_DIST) {",
							"\t\tdiscard;",
							"\t} else {",
							"\t\tvec3 p = ro + rd * d;",
							"\t\tvec3 n = GetNormal(p);",
							"$begin_generate",
							"\t\tif ($flip_y) {",
							"\t\t\tp *= vec3(1.0, -1.0, 1.0);",
							"\t\t\tn *= vec3(1.0, -1.0, 1.0);",
							"\t\t} ",
							"$end_generate",
							"$begin_generate",
							"\t\tALBEDO = $albedo(vec4(p, rm.y));",
							"\t\tROUGHNESS = $roughness(vec4(p, rm.y));",
							"\t\tMETALLIC = $metallic(vec4(p, rm.y));",
							"\t\tEMISSION = $emission(vec4(p, rm.y));",
							"$end_generate",
							"\t\tNORMAL = (INV_VIEW_MATRIX*vec4(n, 0.0)).xyz;",
							"\t}",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				],
				"name": "Godot/Godot 3"
			},
			"Unity": {
				"export_extension": "mat",
				"files": [
					{
						"file_name": "$(path_prefix).shader",
						"template": [
							"Shader \"Custom/NewSurfaceShader\"",
							"{",
							"\tProperties {",
							"$begin_buffers",
							"\t\ttexture_$(buffer_index) (\"Texture $(buffer_index)\", 2D) = \"white\" {}",
							"$end_buffers",
							"\t}",
							"\tSubShader",
							"\t{",
							"\t\tTags { \"RenderType\"=\"Opaque\" }",
							"\t\tLOD 200",
							"\t\tCGPROGRAM",
							"\t\t// Physically based Standard lighting model, and enable shadows on all light types",
							"\t\t#pragma surface surf Standard fullforwardshadows",
							"\t\t// Use shader model 3.0 target, to get nicer looking lighting",
							"\t\t#pragma target 3.0",
							"\t\tstruct Input",
							"\t\t{",
							"\t\t\tfloat3 worldPos;",
							"\t\t\tfloat3 viewDir;",
							"\t\t};",
							"\t\tUNITY_INSTANCING_BUFFER_START(Props)",
							"\t\t\t// put more per-instance properties here",
							"\t\tUNITY_INSTANCING_BUFFER_END(Props)",
							"$definitions hlsl,rename_buffers,unity",
							"\t\tfloat2 sceneSDF(float3 p) {",
							"\t\t\tfloat _seed_variation_ = 0.0;",
							"$begin_generate hlsl,rename_buffers,unity",
							"\t\t\treturn $distance(p);",
							"$end_generate",
							"\t\t}",
							"#define MAX_STEPS 128",
							"#define SURF_DIST 0.001",
							"#define MAX_DIST 1000.0",
							"\t\tfloat2 RayMarch(float3 ro, float3 rd) {",
							"\t\t\tfloat dO = 0.0;",
							"\t\t\tfloat color = 0.0;",
							"\t\t\tfloat2 dS;",
							"\t\t\t",
							"\t\t\tfor (int i = 0; i < MAX_STEPS; i++) {",
							"\t\t\t\tfloat3 p = ro + dO * rd;",
							"\t\t\t\tdS = sceneSDF(p);",
							"\t\t\t\tdO += dS.x;",
							"\t\t\t\t",
							"\t\t\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {",
							"\t\t\t\t\tcolor = dS.y;",
							"\t\t\t\t\tbreak;",
							"\t\t\t\t}",
							"\t\t\t}",
							"\t\t\treturn float2(dO, color);",
							"\t\t}",
							"\t\tfloat3 GetNormal(float3 p) {",
							"\t\t\tfloat2 e = float2(1e-2, 0);",
							"\t\t\t",
							"\t\t\tfloat3 n = sceneSDF(p).x - float3(",
							"\t\t\t\tsceneSDF(p - e.xyy).x,",
							"\t\t\t\tsceneSDF(p - e.yxy).x,",
							"\t\t\t\tsceneSDF(p - e.yyx).x",
							"\t\t\t);",
							"\t\t\t",
							"\t\t\treturn normalize(n);",
							"\t\t}",
							"\t\tvoid surf (Input IN, inout SurfaceOutputStandard o) {",
							"\t\t\tfloat _seed_variation_ = 0.0;",
							"\t\t\tfloat3 ro = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1.0));",
							"\t\t\tfloat3 rd = normalize(mul(unity_WorldToObject, float4(IN.worldPos, 1.0))-ro);",
							"\t\t\tfloat2 dist = RayMarch(ro, rd);",
							"\t\t\tif (dist.x > 99.0) {",
							"\t\t\t\tdiscard;",
							"\t\t\t}",
							"\t\t\tfloat3 p = ro+rd*dist.x;",
							"$begin_generate hlsl,rename_buffers,unity",
							"\t\t\to.Albedo = $albedo(vec4(p, dist.y));",
							"\t\t\to.Metallic = $metallic(vec4(p, dist.y)).x;",
							"\t\t\to.Smoothness = 1.0-$roughness(vec4(p, dist.y)).x;",
							"\t\t\to.Normal = GetNormal(p);",
							"$end_generate",
							"\t\t}",
							"\t\tENDCG",
							"\t}",
							"\tFallBack \"Diffuse\"",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png.meta",
						"template": [
							"fileFormatVersion: 2",
							"guid: $uid(tex_$(buffer_index))",
							"TextureImporter:",
							"  internalIDToNameTable: []",
							"  externalObjects: {}",
							"  serializedVersion: 11",
							"  mipmaps:",
							"\tmipMapMode: 0",
							"\tenableMipMap: 1",
							"\tsRGBTexture: 1",
							"\tlinearTexture: 0",
							"\tfadeOut: 0",
							"\tborderMipMap: 0",
							"\tmipMapsPreserveCoverage: 0",
							"\talphaTestReferenceValue: 0.5",
							"\tmipMapFadeDistanceStart: 1",
							"\tmipMapFadeDistanceEnd: 3",
							"  bumpmap:",
							"\tconvertToNormalMap: 0",
							"\texternalNormalMap: 0",
							"\theightScale: 0.25",
							"\tnormalMapFilter: 0",
							"  isReadable: 0",
							"  streamingMipmaps: 0",
							"  streamingMipmapsPriority: 0",
							"  vTOnly: 0",
							"  grayScaleToAlpha: 0",
							"  generateCubemap: 6",
							"  cubemapConvolution: 0",
							"  seamlessCubemap: 0",
							"  textureFormat: 1",
							"  maxTextureSize: 2048",
							"  textureSettings:",
							"\tserializedVersion: 2",
							"\tfilterMode: -1",
							"\taniso: -1",
							"\tmipBias: -100",
							"\twrapU: -1",
							"\twrapV: -1",
							"\twrapW: -1",
							"  nPOTScale: 1",
							"  lightmap: 0",
							"  compressionQuality: 50",
							"  spriteMode: 0",
							"  spriteExtrude: 1",
							"  spriteMeshType: 1",
							"  alignment: 0",
							"  spritePivot: {x: 0.5, y: 0.5}",
							"  spritePixelsToUnits: 100",
							"  spriteBorder: {x: 0, y: 0, z: 0, w: 0}",
							"  spriteGenerateFallbackPhysicsShape: 1",
							"  alphaUsage: 1",
							"  alphaIsTransparency: 0",
							"  spriteTessellationDetail: -1",
							"  textureType: 0",
							"  textureShape: 1",
							"  singleChannelComponent: 0",
							"  flipbookRows: 1",
							"  flipbookColumns: 1",
							"  maxTextureSizeSet: 0",
							"  compressionQualitySet: 0",
							"  textureFormatSet: 0",
							"  ignorePngGamma: 0",
							"  applyGammaDecoding: 0",
							"  platformSettings:",
							"  - serializedVersion: 3",
							"\tbuildTarget: DefaultTexturePlatform",
							"\tmaxTextureSize: 2048",
							"\tresizeAlgorithm: 0",
							"\ttextureFormat: -1",
							"\ttextureCompression: 1",
							"\tcompressionQuality: 50",
							"\tcrunchedCompression: 0",
							"\tallowsAlphaSplitting: 0",
							"\toverridden: 0",
							"\tandroidETC2FallbackOverride: 0",
							"\tforceMaximumCompressionQuality_BC6H_BC7: 0",
							"  spriteSheet:",
							"\tserializedVersion: 2",
							"\tsprites: []",
							"\toutline: []",
							"\tphysicsShape: []",
							"\tbones: []",
							"\tspriteID: ",
							"\tinternalID: 0",
							"\tvertices: []",
							"\tindices: ",
							"\tedges: []",
							"\tweights: []",
							"\tsecondaryTextures: []",
							"  spritePackingTag: ",
							"  pSDRemoveMatte: 0",
							"  pSDShowRemoveMatteOption: 0",
							"  userData: ",
							"  assetBundleName: ",
							"  assetBundleVariant: ",
							""
						],
						"type": "buffer_templates"
					},
					{
						"file_name": "$(path_prefix).mat",
						"template": [
							"%YAML 1.1",
							"%TAG !u! tag:unity3d.com,2011:",
							"--- !u!21 &2100000",
							"Material:",
							"  serializedVersion: 6",
							"  m_ObjectHideFlags: 0",
							"  m_CorrespondingSourceObject: {fileID: 0}",
							"  m_PrefabInstance: {fileID: 0}",
							"  m_PrefabAsset: {fileID: 0}",
							"  m_Name: test2",
							"  m_Shader: {fileID: 4800000, guid: $uid(shader), type: 3}",
							"  m_ShaderKeywords: ",
							"  m_LightmapFlags: 4",
							"  m_EnableInstancingVariants: 0",
							"  m_DoubleSidedGI: 0",
							"  m_CustomRenderQueue: -1",
							"  stringTagMap: {}",
							"  disabledShaderPasses: []",
							"  m_SavedProperties:",
							"    serializedVersion: 3",
							"    m_TexEnvs:",
							"    - _MainTex:",
							"        m_Texture: {fileID: 2800000, guid: 6c5d2d4e94384751a0ce7d6619e0d49a, type: 3}",
							"        m_Scale: {x: 1, y: 1}",
							"        m_Offset: {x: 0, y: 0}",
							"$begin_buffers",
							"    - texture_$(buffer_index):",
							"        m_Texture: {fileID: 2800000, guid: $uid(tex_$(buffer_index)), type: 3}",
							"        m_Scale: {x: 1, y: 1}",
							"        m_Offset: {x: 0, y: 0}",
							"$end_buffers",
							"  m_BuildTextureStacks: []",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).shader.meta",
						"template": [
							"fileFormatVersion: 2",
							"guid: $uid(shader)",
							"ShaderImporter:",
							"  externalObjects: {}",
							"  defaultTextures: []",
							"  nonModifiableTextures: []",
							"  preprocessorOverride: 0",
							"  userData: ",
							"  assetBundleName: ",
							"  assetBundleVariant: ",
							""
						],
						"type": "template"
					}
				]
			},
			"Unreal/Unreal Engine 4": {
				"export_extension": "mm2ue",
				"files": [
					{
						"file_name": "$(path_prefix).mm2ue",
						"template": [
							"/*",
							"Instructions to setup this material:",
							"- copy material_raymarching.uasset and open the copy",
							"- copy the shader code below and paste it into the Custom node",
							"$begin_buffers",
							"- create a TextureObject for $(file_prefix)_texture_$(buffer_index).png in the graph",
							"  and a new input for texture_$(buffer_index) in the custom node, and connect them",
							"$end_buffers",
							"*/",
							"struct Functions {",
							"$definitions hlsl,rename_buffers,unreal",
							"\tfloat2 sceneSDF(float3 p) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tp = p.xzy/Scale;",
							"$begin_generate hlsl,rename_buffers,unreal",
							"\t\tfloat2 d = $distance(p);",
							"$end_generate",
							"\t\treturn float2(d.x*Scale, d.y);",
							"\t}",
							"#define MAX_STEPS 128",
							"#define SURF_DIST 0.1",
							"#define MAX_DIST 1000.0",
							"\tfloat2 RayMarch(float3 ro, float3 rd) {",
							"\t\tfloat dO = 0.0;",
							"\t\tfloat color = 0.0;",
							"\t\tfloat2 dS;",
							"\t\t",
							"\t\tfor (int i = 0; i < MAX_STEPS; i++) {",
							"\t\t\tfloat3 p = ro + dO * rd;",
							"\t\t\tdS = sceneSDF(p);",
							"\t\t\tdO += dS.x;",
							"\t\t\t",
							"\t\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {",
							"\t\t\t\tcolor = dS.y;",
							"\t\t\t\tbreak;",
							"\t\t\t}",
							"\t\t}",
							"\t\treturn float2(dO, color);",
							"\t}",
							"\tfloat3 GetNormal(float3 p) {",
							"\t\tfloat2 e = float2(1e-2, 0);",
							"\t\t",
							"\t\tfloat3 n = sceneSDF(p).x - float3(",
							"\t\t\tsceneSDF(p - e.xyy).x,",
							"\t\t\tsceneSDF(p - e.yxy).x,",
							"\t\t\tsceneSDF(p - e.yyx).x",
							"\t\t);",
							"\t\t",
							"\t\treturn normalize(n);",
							"\t}",
							"\tfloat4 generated_shader(float3 CameraPosition, float3 RayDirection, out float metallic, out float roughness, out float3 normal) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tfloat3 ro = CameraPosition;",
							"\t\tfloat3 rd = RayDirection;",
							"\t\tfloat2 dist = RayMarch(ro, rd);",
							"\t\tfloat3 p = ro+dist.x*rd;",
							"\t\tfloat4 pc = tofloat4(p.xzy/Scale, dist.y);",
							"\t\tfloat alpha = (dist < MAX_DIST) ? 1.0 : 0.0;",
							"$begin_generate hlsl,rename_buffers,unreal",
							"\t\tfloat4 albedo = tofloat4($albedo(pc), alpha);",
							"\t\tmetallic = $metallic(pc).x;",
							"\t\troughness = $roughness(pc).x;",
							"$end_generate",
							"\t\tnormal = GetNormal(p.xzy);",
							"\t\treturn albedo;",
							"\t}",
							"};",
							"Functions f;",
							"float4 albedo = f.generated_shader(CameraPosition, RayDirection, metallic, roughness, normal);",
							"return albedo;",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(file_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				],
				"name": "Unreal/Unreal Engine 4"
			},
			"Unreal/Unreal Engine 5": {
				"export_extension": "py",
				"files": [
					{
						"file_name": "$(path_prefix).py",
						"template": [
							"import unreal",
							"import sys",
							"sys.path.append('$(material_maker_path)$(path_separator)export')",
							"import mm",
							"from importlib import reload",
							"reload(mm)",
							"mat = mm.Material('$(file_prefix)', True)",
							"mat.clear()",
							"mat.set_editor_property('blend_mode', unreal.BlendMode.BLEND_MASKED)",
							"MaterialFunctionCall_1 = mat.add_node('MaterialFunctionCall', -288, 192)",
							"MaterialFunctionCall_1.set_editor_property('material_function', mm.get_object_from_path(\"/Script/Engine.MaterialFunction'/Engine/Functions/Engine_MaterialFunctions02/Utility/BreakOutFloat4Components.BreakOutFloat4Components'\"))",
							"Custom_0 = mat.add_node('Custom', -576, 0)",
							"Custom_0.set_editor_property('code', mm.read_text_file('$(path_prefix).shader'))",
							"Custom_0.set_editor_property('output_type', unreal.CustomMaterialOutputType.CMOT_FLOAT4)",
							"Custom_0.set_editor_property('additional_outputs', [ mm.custom_output('metallic', 1), mm.custom_output('roughness', 1), mm.custom_output('normal', 3), mm.custom_output('emission', 3)])",
							"inputs = [mm.custom_input('CameraPosition'), mm.custom_input('RayDirection'), mm.custom_input('Time'), mm.custom_input('Scale')]",
							"$begin_buffers",
							"inputs.append(mm.custom_input('texture_$(buffer_index)'))",
							"$end_buffers",
							"Custom_0.set_editor_property('inputs', inputs)",
							"TransformPosition_0 = mat.add_node('TransformPosition', -1136, 16)",
							"Normalize_0 = mat.add_node('Normalize', -736, -16)",
							"Time_0 = mat.add_node('Time', -752, 64)",
							"Constant_0 = mat.add_node('Constant', -752, 192)",
							"Constant_0.set_editor_property('r', 100.0)",
							"CameraPositionWS_0 = mat.add_node('CameraPositionWS', -1312, 16)",
							"Subtract_0 = mat.add_node('Subtract', -864, -16)",
							"MaterialFunctionCall_0 = mat.add_node('MaterialFunctionCall', -1152, -160)",
							"MaterialFunctionCall_0.set_editor_property('material_function', mm.get_object_from_path(\"/Script/Engine.MaterialFunction'/Engine/Functions/Engine_MaterialFunctions02/WorldPositionOffset/LocalPosition.LocalPosition'\"))",
							"$begin_buffers",
							"Texture_$(buffer_index) = mat.add_node('TextureObject',  -752, $(expr:110+170*$(buffer_index)))",
							"Texture_$(buffer_index).set_editor_property('texture', mm.import_texture('$(path_prefix)_texture_$(buffer_index).png', '/Game/Textures'))",
							"$end_buffers",
							"mat.connect_property(MaterialFunctionCall_1, 'A', unreal.MaterialProperty.MP_OPACITY_MASK)",
							"mat.connect_property(Custom_0, 'return', unreal.MaterialProperty.MP_BASE_COLOR)",
							"mat.connect_property(Custom_0, 'metallic', unreal.MaterialProperty.MP_METALLIC)",
							"mat.connect_property(Custom_0, 'roughness', unreal.MaterialProperty.MP_ROUGHNESS)",
							"mat.connect_nodes(Custom_0, 'return', MaterialFunctionCall_1, '')",
							"mat.connect_nodes(TransformPosition_0, '', Custom_0, 'CameraPosition')",
							"mat.connect_nodes(Normalize_0, '', Custom_0, 'RayDirection')",
							"mat.connect_nodes(Time_0, '', Custom_0, 'Time')",
							"mat.connect_nodes(Constant_0, '', Custom_0, 'Scale')",
							"mat.connect_nodes(CameraPositionWS_0, '', TransformPosition_0, '')",
							"mat.connect_nodes(Subtract_0, '', Normalize_0, '')",
							"mat.connect_nodes(MaterialFunctionCall_0, 'Local Position', Subtract_0, 'A')",
							"mat.connect_nodes(TransformPosition_0, '', Subtract_0, 'B')",
							"$begin_buffers",
							"mat.connect_nodes(Texture_$(buffer_index), '', Custom_0, 'texture_$(buffer_index)')",
							"$end_buffers",
							"mat.save()",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(file_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					},
					{
						"file_name": "$(path_prefix).shader",
						"template": [
							"struct Functions {",
							"\tfloat Time;",
							"\tfloat Scale;",
							"$begin_buffers",
							"\tTexture2D texture_$(buffer_index);",
							"\tSamplerState texture_$(buffer_index)Sampler;",
							"$end_buffers",
							"$definitions hlsl_base,rename_buffers,unreal5",
							"\tfloat2 sceneSDF(float3 p) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tp = p.xzy/Scale;",
							"$begin_generate hlsl_base,rename_buffers,unreal5",
							"\t\tfloat2 d = $distance(p);",
							"$end_generate",
							"\t\treturn float2(d.x*Scale, d.y);",
							"\t}",
							"#define MAX_STEPS 128",
							"#define SURF_DIST 0.1",
							"#define MAX_DIST 1000.0",
							"\tfloat2 RayMarch(float3 ro, float3 rd) {",
							"\t\tfloat dO = 0.0;",
							"\t\tfloat color = 0.0;",
							"\t\tfloat2 dS;",
							"\t\t",
							"\t\tfor (int i = 0; i < MAX_STEPS; i++) {",
							"\t\t\tfloat3 p = ro + dO * rd;",
							"\t\t\tdS = sceneSDF(p);",
							"\t\t\tdO += dS.x;",
							"\t\t\t",
							"\t\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {",
							"\t\t\t\tcolor = dS.y;",
							"\t\t\t\tbreak;",
							"\t\t\t}",
							"\t\t}",
							"\t\treturn float2(dO, color);",
							"\t}",
							"\tfloat3 GetNormal(float3 p) {",
							"\t\tfloat2 e = float2(1e-2, 0);",
							"\t\t",
							"\t\tfloat3 n = sceneSDF(p).x - float3(",
							"\t\t\tsceneSDF(p - e.xyy).x,",
							"\t\t\tsceneSDF(p - e.yxy).x,",
							"\t\t\tsceneSDF(p - e.yyx).x",
							"\t\t);",
							"\t\t",
							"\t\treturn normalize(n);",
							"\t}",
							"\tfloat4 generated_shader(float3 CameraPosition, float3 RayDirection, float _time, float _scale,",
							"$begin_buffers",
							"\t\t\t\t\t\t\tTexture2D _texture_$(buffer_index), SamplerState _texture_$(buffer_index)Sampler,",
							"$end_buffers",
							"\t\t\t\t\t\t\tout float metallic, out float roughness, out float3 normal) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tTime = _time;",
							"\t\tScale = _scale;",
							"$begin_buffers",
							"\t\ttexture_$(buffer_index) = _texture_$(buffer_index);",
							"\t\ttexture_$(buffer_index)Sampler = _texture_$(buffer_index)Sampler;",
							"$end_buffers",
							"\t\tfloat3 ro = CameraPosition;",
							"\t\tfloat3 rd = RayDirection;",
							"\t\tfloat2 dist = RayMarch(ro, rd);",
							"\t\tfloat3 p = ro+dist.x*rd;",
							"\t\tfloat4 pc = tofloat4(p.xzy/Scale, dist.y);",
							"\t\tfloat alpha = (dist < MAX_DIST) ? 1.0 : 0.0;",
							"$begin_generate hlsl_base,rename_buffers,unreal5",
							"\t\tfloat4 albedo = tofloat4($albedo(pc), alpha);",
							"\t\tmetallic = $metallic(pc).x;",
							"\t\troughness = $roughness(pc).x;",
							"$end_generate",
							"\t\tnormal = GetNormal(p.xzy);",
							"\t\treturn albedo;",
							"\t}",
							"};",
							"Functions f;",
							"float4 albedo = f.generated_shader(CameraPosition, RayDirection, Time, Scale,",
							"$begin_buffers",
							"\t\t\t\t\t\t\t\t   texture_$(buffer_index), texture_$(buffer_index)Sampler,",
							"$end_buffers",
							"\t\t\t\t\t\t\t\t   metallic, roughness, normal);",
							"return albedo;",
							""
						],
						"type": "template"
					},
					{
						"file_name": "clipboard",
						"template": "\"$(path_prefix).py\"",
						"type": "template"
					}
				],
				"name": "Unreal/Unreal Engine 4"
			}
		},
		"global": "",
		"inputs": [
			{
				"default": "vec2(0.0)",
				"function": true,
				"label": "",
				"name": "distance",
				"shortdesc": "Distance",
				"type": "sdf3dc"
			},
			{
				"default": "vec3(1.0)",
				"label": "",
				"name": "albedo",
				"shortdesc": "Albedo",
				"type": "tex3d"
			},
			{
				"default": "0.0",
				"label": "",
				"name": "metallic",
				"shortdesc": "Metallic",
				"type": "tex3d_gs"
			},
			{
				"default": "1.0",
				"label": "",
				"name": "roughness",
				"shortdesc": "Roughness",
				"type": "tex3d_gs"
			},
			{
				"default": "vec3(0.0)",
				"label": "",
				"name": "emission",
				"shortdesc": "Emission",
				"type": "tex3d"
			}
		],
		"instance": "",
		"name": "Raymarching Material",
		"outputs": [

		],
		"parameters": [
			{
				"default": false,
				"label": "Flip Y",
				"name": "flip_y",
				"type": "boolean"
			}
		],
		"preview_shader": [
			"shader_type spatial;",
			"",
			"varying float elapsed_time;",
			"",
			"varying vec3 world_camera;",
			"varying vec3 world_position;",
			"",
			"const int MAX_STEPS = 100;",
			"const float MAX_DIST = 100.0;",
			"const float SURF_DIST = 1e-3;",
			"",
			"$definitions",
			"",
			"vec2 GetDist(vec3 p) {",
			"\tfloat _seed_variation_ = 0.0;",
			"\t",
			"$begin_generate",
			"\t\tif ($flip_y) {",
			"\t\t\tp *= vec3(1.0, -1.0, 1.0);",
			"\t\t} ",
			"$end_generate",
			"$begin_generate",
			"\tvec2 d = $distance(p);",
			"$end_generate",
			"",
			"\treturn d;",
			"}",
			"",
			"vec2 RayMarch(vec3 ro, vec3 rd) {",
			"\tfloat dO = 0.0;",
			"\tfloat color = 0.0;",
			"\tvec2 dS;",
			"\t",
			"\tfor (int i = 0; i < MAX_STEPS; i++)",
			"\t{",
			"\t\tvec3 p = ro + dO * rd;",
			"\t\tdS = GetDist(p);",
			"\t\tdO += dS.x;",
			"\t\t",
			"\t\tif (abs(dS.x) < SURF_DIST || dO > MAX_DIST) {",
			"\t\t\tcolor = dS.y;",
			"\t\t\tbreak;",
			"\t\t}",
			"\t}",
			"\treturn vec2(dO, color);",
			"}",
			"",
			"vec3 GetNormal(vec3 p) {",
			"\tvec2 e = vec2(1e-3, 0);",
			"\t",
			"\tvec3 n = GetDist(p).x - vec3(",
			"\t\tGetDist(p - e.xyy).x,",
			"\t\tGetDist(p - e.yxy).x,",
			"\t\tGetDist(p - e.yyx).x",
			"\t);",
			"\t",
			"\treturn normalize(n);",
			"}",
			"",
			"void vertex() {",
			"\telapsed_time = TIME;",
			"\tworld_position = VERTEX;",
			"\tworld_camera = (inverse(MODELVIEW_MATRIX) * vec4(0, 0, 0, 1)).xyz; //object space",
			"\t//world_camera = ( CAMERA_MATRIX  * vec4(0, 0, 0, 1)).xyz; //uncomment this to raymarch in world space",
			"}",
			"",
			"void fragment() {",
			"\tfloat _seed_variation_ = 0.0;",
			"\tvec3 ro = world_camera;",
			"\tvec3 rd =  normalize(world_position - ro);",
			"\t",
			"\tvec2 rm  = RayMarch(ro, rd);",
			"\tfloat d = rm.x;",
			"",
			"\tif (d >= MAX_DIST)",
			"\t\tdiscard;",
			"\telse",
			"\t{",
			"\t\tvec3 p = ro + rd * d;",
			"\t\tvec3 n = GetNormal(p);",
			"$begin_generate",
			"\t\tif ($flip_y) {",
			"\t\t\tp *= vec3(1.0, -1.0, 1.0);",
			"\t\t\tn *= vec3(1.0, -1.0, 1.0);",
			"\t\t} ",
			"$end_generate",
			"$begin_generate",
			"\t\tALBEDO = $albedo(vec4(p, rm.y));",
			"\t\tROUGHNESS = $roughness(vec4(p, rm.y));",
			"\t\tMETALLIC = $metallic(vec4(p, rm.y));",
			"\t\tEMISSION = $emission(vec4(p, rm.y));",
			"$end_generate",
			"\t\tNORMAL = (INV_VIEW_MATRIX*vec4(n, 0.0)).xyz;",
			"\t}",
			"}",
			""
		]
	},
	"type": "material_export"
}