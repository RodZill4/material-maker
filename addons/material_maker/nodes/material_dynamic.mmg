{
	"export": {

	},
	"name": "material_dynamic",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"albedo_color": {
			"a": 1,
			"b": 1,
			"g": 1,
			"r": 1,
			"type": "Color"
		},
		"ao": 1,
		"depth_scale": 0.2,
		"emission_energy": 1,
		"flags_transparent": false,
		"metallic": 1,
		"normal": 1,
		"roughness": 1
	},
	"seed_int": 0,
	"shader_model": {
		"shortdesc": "Dynamic PBR Material",
		"longdesc": "PBR material with shader-generated maps, which enables creation of animated, resolution independent or non-repetitive materials",
		"code": "",
		"custom": "",
		"exports": {
			"Godot/Godot 3": {
				"export_extension": "tres",
				"files": [
					{
						"file_name": "$(path_prefix).tres",
						"prompt_overwrite": true,
						"template": [
							"[gd_resource type=\"ShaderMaterial\" load_steps=2 format=2]",
							"[ext_resource path=\"$(file_prefix).gdshader\" type=\"Shader\" id=1]",
							"$begin_buffers",
							"[ext_resource path=\"$(file_prefix)_texture_$(buffer_index).png\" type=\"Texture\" id=$(expr:$(buffer_index)+1)]",
							"$end_buffers",
							"[resource]",
							"shader = ExtResource( 1 )",
							"$begin_buffers",
							"shader_param/texture_$(buffer_index) = ExtResource( $(expr:$(buffer_index)+1) )",
							"$end_buffers",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).gdshader",
						"prompt_overwrite": false,
						"template": [
							"shader_type spatial;",
							"render_mode blend_mix,cull_back,diffuse_burley,specular_schlick_ggx",
							"$if $(connected:opacity_tex) and $(param:flags_transparent)",
							",depth_draw_alpha_prepass",
							"$fi",
							";",
							"uniform vec3 uv1_offset = vec3(0.0, 0.0, 0.0);",
							"uniform vec3 uv1_scale = vec3(1.0, 1.0, 1.0);",
							"uniform int depth_min_layers = 8;",
							"uniform int depth_max_layers = 16;",
							"uniform vec2 depth_flip = vec2(1.0);",
							"uniform float variation = 0.0;",
							"varying float elapsed_time;",
							"void vertex() {",
							"\telapsed_time = TIME;",
							"\tUV = UV*uv1_scale.xy+uv1_offset.xy;",
							"}",
							"$definitions float_uniform_to_const,rename_buffers",
							"void fragment() {",
							"\tfloat _seed_variation_ = variation;",
							"\tvec4 _controlled_variation_ = vec4(0.0);",
							"\tvec2 uv = fract(UV);",
							"$if $(connected:depth_tex)",
							"\t{",
							"$begin_generate",
							"\t\tfloat depth_scale = 0.2*$depth_scale;",
							"$end_generate",
							"\t\tvec3 view_dir = normalize(normalize(-VERTEX)*mat3(TANGENT*depth_flip.x,-BINORMAL*depth_flip.y,NORMAL));",
							"\t\tfloat num_layers = mix(float(depth_max_layers),float(depth_min_layers), abs(dot(vec3(0.0, 0.0, 1.0), view_dir)));",
							"\t\tfloat layer_depth = 1.0 / num_layers;",
							"\t\tfloat current_layer_depth = 0.0;",
							"\t\tvec2 P = view_dir.xy * depth_scale;",
							"\t\tvec2 delta = P / num_layers / dot(VIEW, NORMAL);",
							"\t\tvec2  ofs = uv;",
							"$begin_generate",
							"\t\tfloat depth = $depth_tex(ofs);",
							"$end_generate",
							"\t\tfloat current_depth = 0.0;",
							"\t\twhile(current_depth < depth) {",
							"\t\t\tofs -= delta;",
							"$begin_generate",
							"\t\t\tdepth = $depth_tex(ofs);",
							"$end_generate",
							"\t\t\tcurrent_depth += layer_depth;",
							"\t\t}",
							"\t\tvec2 prev_ofs = ofs + delta;",
							"\t\tfloat after_depth  = depth - current_depth;",
							"$begin_generate",
							"\t\tfloat before_depth = $depth_tex(prev_ofs) - current_depth + layer_depth;",
							"$end_generate",
							"\t\tfloat weight = after_depth / (after_depth - before_depth);",
							"\t\tofs = mix(ofs, prev_ofs, weight);",
							"\t\tuv = ofs;",
							"\t}",
							"$fi",
							"$begin_generate rename_buffers",
							"\tvec3 albedo_tex = $albedo_tex(uv).rgb;",
							"\talbedo_tex = mix(pow((albedo_tex + vec3(0.055)) * (1.0 / (1.0 + 0.055)),vec3(2.4)),albedo_tex * (1.0 / 12.92),lessThan(albedo_tex,vec3(0.04045)));",
							"\tALBEDO = albedo_tex*$albedo_color.rgb;",
							"\tMETALLIC = $metallic_tex(uv)*$metallic;",
							"\tROUGHNESS = $roughness_tex(uv)*$roughness;",
							"\tNORMALMAP = $normal_tex(uv);",
							"\tEMISSION = $emission_tex(uv)*$emission_energy;",
							"$if $(connected:opacity_tex) and $(param:flags_transparent)",
							"\tALPHA = $opacity_tex(uv);",
							"$fi",
							"$end_generate",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				]
			},
			"Godot/Godot 4": {
				"export_extension": "tres",
				"files": [
					{
						"file_name": "$(path_prefix).tres",
						"prompt_overwrite": true,
						"template": [
							"[gd_resource type=\"ShaderMaterial\" load_steps=2 format=2]",
							"[ext_resource path=\"$(file_prefix).gdshader\" type=\"Shader\" id=1]",
							"$begin_buffers",
							"[ext_resource path=\"$(file_prefix)_texture_$(buffer_index).png\" type=\"Texture\" id=$(expr:$(buffer_index)+1)]",
							"$end_buffers",
							"[resource]",
							"shader = ExtResource( 1 )",
							"$begin_buffers",
							"shader_parameter/texture_$(buffer_index) = ExtResource( $(expr:$(buffer_index)+1) )",
							"$end_buffers",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).gdshader",
						"prompt_overwrite": false,
						"template": [
							"shader_type spatial;",
							"render_mode blend_mix,cull_back,diffuse_burley,specular_schlick_ggx",
							"$if $(connected:opacity_tex) and $(param:flags_transparent)",
							",depth_draw_opaque",
							"$fi",
							";",
							"uniform vec3 uv1_offset = vec3(0.0, 0.0, 0.0);",
							"uniform vec3 uv1_scale = vec3(1.0, 1.0, 1.0);",
							"uniform int depth_min_layers = 8;",
							"uniform int depth_max_layers = 16;",
							"uniform vec2 depth_flip = vec2(1.0);",
							"uniform float variation = 0.0;",
							"varying float elapsed_time;",
							"void vertex() {",
							"\telapsed_time = TIME;",
							"\tUV = UV*uv1_scale.xy+uv1_offset.xy;",
							"}",
							"$definitions float_uniform_to_const,rename_buffers",
							"void fragment() {",
							"\tfloat _seed_variation_ = variation;",
							"\tvec4 _controlled_variation_ = vec4(0.0);",
							"\tvec2 uv = fract(UV);",
							"$if $(connected:depth_tex)",
							"\t{",
							"$begin_generate",
							"\t\tfloat depth_scale = 0.2*$depth_scale;",
							"$end_generate",
							"\t\tvec3 view_dir = normalize(normalize(-VERTEX)*mat3(TANGENT*depth_flip.x,-BINORMAL*depth_flip.y,NORMAL));",
							"\t\tfloat num_layers = mix(float(depth_max_layers),float(depth_min_layers), abs(dot(vec3(0.0, 0.0, 1.0), view_dir)));",
							"\t\tfloat layer_depth = 1.0 / num_layers;",
							"\t\tfloat current_layer_depth = 0.0;",
							"\t\tvec2 P = view_dir.xy * depth_scale;",
							"\t\tvec2 delta = P / num_layers / dot(VIEW, NORMAL);",
							"\t\tvec2  ofs = uv;",
							"$begin_generate",
							"\t\tfloat depth = $depth_tex(ofs);",
							"$end_generate",
							"\t\tfloat current_depth = 0.0;",
							"\t\twhile(current_depth < depth) {",
							"\t\t\tofs -= delta;",
							"$begin_generate",
							"\t\t\tdepth = $depth_tex(ofs);",
							"$end_generate",
							"\t\t\tcurrent_depth += layer_depth;",
							"\t\t}",
							"\t\tvec2 prev_ofs = ofs + delta;",
							"\t\tfloat after_depth  = depth - current_depth;",
							"$begin_generate",
							"\t\tfloat before_depth = $depth_tex(prev_ofs) - current_depth + layer_depth;",
							"$end_generate",
							"\t\tfloat weight = after_depth / (after_depth - before_depth);",
							"\t\tofs = mix(ofs, prev_ofs, weight);",
							"\t\tuv = ofs;",
							"\t}",
							"$fi",
							"$begin_generate rename_buffers",
							"\tvec3 albedo_tex = $albedo_tex(uv).rgb;",
							"\talbedo_tex = mix(pow((albedo_tex + vec3(0.055)) * (1.0 / (1.0 + 0.055)),vec3(2.4)),albedo_tex * (1.0 / 12.92),lessThan(albedo_tex,vec3(0.04045)));",
							"\tALBEDO = albedo_tex*$albedo_color.rgb;",
							"\tMETALLIC = $metallic_tex(uv)*$metallic;",
							"\tROUGHNESS = $roughness_tex(uv)*$roughness;",
							"\tNORMAL_MAP = $normal_tex(uv);",
							"\tNORMAL_MAP_DEPTH = $normal;",
							"\tEMISSION = $emission_tex(uv)*$emission_energy;",
							"$if $(connected:opacity_tex) and $(param:flags_transparent)",
							"\tALPHA = $opacity_tex(uv);",
							"$fi",
							"$end_generate",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				]
			},
			"Unity": {
				"export_extension": "mat",
				"files": [
					{
						"file_name": "$(path_prefix).shader",
						"template": [
							"Shader \"Custom/NewSurfaceShader\"",
							"{",
							"\tProperties {",
							"$begin_buffers",
							"\t\ttexture_$(buffer_index) (\"Texture $(buffer_index)\", 2D) = \"white\" {}",
							"$end_buffers",
							"\t\t_MainTex (\"Foo\", 2D) = \"white\" {}",
							"\t}",
							"\tSubShader {",
							"\t\tTags { \"RenderType\"=\"Opaque\" }",
							"\t\tLOD 200",
							"\t\tCGPROGRAM",
							"\t\t#pragma surface surf Standard fullforwardshadows",
							"\t\t#pragma target 3.0",
							"\t\t",
							"\t\tsampler2D _MainTex;",
							"\t\tstruct Input {",
							"\t\t\tfloat2 uv_MainTex;",
							"\t\t};",
							"\t\tUNITY_INSTANCING_BUFFER_START(Props)",
							"\t\tUNITY_INSTANCING_BUFFER_END(Props)",
							"\t\t",
							"$definitions hlsl,rename_buffers,unity",
							"\t\t",
							"\t\tvoid surf (Input IN, inout SurfaceOutputStandard o) {",
							"\t\t\tfloat _seed_variation_ = 0.0;",
							"\t\t\tfloat4 _controlled_variation_ = float4(0.0, 0.0, 0.0, 0.0);",
							"\t\t\tfloat2 uv = IN.uv_MainTex;",
							"$begin_generate hlsl,rename_buffers,unity",
							"\t\t\to.Albedo = $albedo_tex(uv).rgb*$albedo_color.rgb;",
							"\t\t\to.Metallic = $metallic_tex(uv)*$metallic;",
							"\t\t\to.Smoothness = 1.0-$roughness_tex(uv)*$roughness;",
							"\t\t\to.Alpha = 1.0;",
							"\t\t\to.Normal = $normal_tex(uv)*vec3(-1.0, 1.0, -1.0)+vec3(1.0, 0.0, 1.0);",
							"$end_generate",
							"\t\t}",
							"\t\tENDCG",
							"\t}",
							"\tFallBack \"Diffuse\"",
							"}",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png.meta",
						"template": [
							"fileFormatVersion: 2",
							"guid: $uid(tex_$(buffer_index))",
							"TextureImporter:",
							"  internalIDToNameTable: []",
							"  externalObjects: {}",
							"  serializedVersion: 11",
							"  mipmaps:",
							"\tmipMapMode: 0",
							"\tenableMipMap: 1",
							"\tsRGBTexture: 1",
							"\tlinearTexture: 0",
							"\tfadeOut: 0",
							"\tborderMipMap: 0",
							"\tmipMapsPreserveCoverage: 0",
							"\talphaTestReferenceValue: 0.5",
							"\tmipMapFadeDistanceStart: 1",
							"\tmipMapFadeDistanceEnd: 3",
							"  bumpmap:",
							"\tconvertToNormalMap: 0",
							"\texternalNormalMap: 0",
							"\theightScale: 0.25",
							"\tnormalMapFilter: 0",
							"  isReadable: 0",
							"  streamingMipmaps: 0",
							"  streamingMipmapsPriority: 0",
							"  vTOnly: 0",
							"  grayScaleToAlpha: 0",
							"  generateCubemap: 6",
							"  cubemapConvolution: 0",
							"  seamlessCubemap: 0",
							"  textureFormat: 1",
							"  maxTextureSize: 2048",
							"  textureSettings:",
							"\tserializedVersion: 2",
							"\tfilterMode: -1",
							"\taniso: -1",
							"\tmipBias: -100",
							"\twrapU: -1",
							"\twrapV: -1",
							"\twrapW: -1",
							"  nPOTScale: 1",
							"  lightmap: 0",
							"  compressionQuality: 50",
							"  spriteMode: 0",
							"  spriteExtrude: 1",
							"  spriteMeshType: 1",
							"  alignment: 0",
							"  spritePivot: {x: 0.5, y: 0.5}",
							"  spritePixelsToUnits: 100",
							"  spriteBorder: {x: 0, y: 0, z: 0, w: 0}",
							"  spriteGenerateFallbackPhysicsShape: 1",
							"  alphaUsage: 1",
							"  alphaIsTransparency: 0",
							"  spriteTessellationDetail: -1",
							"  textureType: 0",
							"  textureShape: 1",
							"  singleChannelComponent: 0",
							"  flipbookRows: 1",
							"  flipbookColumns: 1",
							"  maxTextureSizeSet: 0",
							"  compressionQualitySet: 0",
							"  textureFormatSet: 0",
							"  ignorePngGamma: 0",
							"  applyGammaDecoding: 0",
							"  platformSettings:",
							"  - serializedVersion: 3",
							"\tbuildTarget: DefaultTexturePlatform",
							"\tmaxTextureSize: 2048",
							"\tresizeAlgorithm: 0",
							"\ttextureFormat: -1",
							"\ttextureCompression: 1",
							"\tcompressionQuality: 50",
							"\tcrunchedCompression: 0",
							"\tallowsAlphaSplitting: 0",
							"\toverridden: 0",
							"\tandroidETC2FallbackOverride: 0",
							"\tforceMaximumCompressionQuality_BC6H_BC7: 0",
							"  spriteSheet:",
							"\tserializedVersion: 2",
							"\tsprites: []",
							"\toutline: []",
							"\tphysicsShape: []",
							"\tbones: []",
							"\tspriteID: ",
							"\tinternalID: 0",
							"\tvertices: []",
							"\tindices: ",
							"\tedges: []",
							"\tweights: []",
							"\tsecondaryTextures: []",
							"  spritePackingTag: ",
							"  pSDRemoveMatte: 0",
							"  pSDShowRemoveMatteOption: 0",
							"  userData: ",
							"  assetBundleName: ",
							"  assetBundleVariant: ",
							""
						],
						"type": "buffer_templates"
					},
					{
						"file_name": "$(path_prefix).mat",
						"template": [
							"%YAML 1.1",
							"%TAG !u! tag:unity3d.com,2011:",
							"--- !u!21 &2100000",
							"Material:",
							"  serializedVersion: 6",
							"  m_ObjectHideFlags: 0",
							"  m_CorrespondingSourceObject: {fileID: 0}",
							"  m_PrefabInstance: {fileID: 0}",
							"  m_PrefabAsset: {fileID: 0}",
							"  m_Name: $(file_prefix)",
							"  m_Shader: {fileID: 4800000, guid: $uid(shader), type: 3}",
							"  m_ShaderKeywords: ",
							"  m_LightmapFlags: 4",
							"  m_EnableInstancingVariants: 0",
							"  m_DoubleSidedGI: 0",
							"  m_CustomRenderQueue: -1",
							"  stringTagMap: {}",
							"  disabledShaderPasses: []",
							"  m_SavedProperties:",
							"    serializedVersion: 3",
							"    m_TexEnvs:",
							"    - _MainTex:",
							"        m_Texture: {fileID: 2800000, guid: 6c5d2d4e94384751a0ce7d6619e0d49a, type: 3}",
							"        m_Scale: {x: 1, y: 1}",
							"        m_Offset: {x: 0, y: 0}",
							"$begin_buffers",
							"    - texture_$(buffer_index):",
							"        m_Texture: {fileID: 2800000, guid: $uid(tex_$(buffer_index)), type: 3}",
							"        m_Scale: {x: 1, y: 1}",
							"        m_Offset: {x: 0, y: 0}",
							"$end_buffers",
							"  m_BuildTextureStacks: []",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).shader.meta",
						"template": [
							"fileFormatVersion: 2",
							"guid: $uid(shader)",
							"ShaderImporter:",
							"  externalObjects: {}",
							"  defaultTextures: []",
							"  nonModifiableTextures: []",
							"  preprocessorOverride: 0",
							"  userData: ",
							"  assetBundleName: ",
							"  assetBundleVariant: ",
							""
						],
						"type": "template"
					}
				]
			},
			"Unreal/Unreal Engine 4": {
				"export_extension": "mm2ue",
				"files": [
					{
						"file_name": "$(path_prefix).mm2ue",
						"prompt_overwrite": false,
						"template": [
							"/*",
							"Instructions to setup this material:",
							"- copy material_dynamic.uasset and open the copy",
							"$begin_buffers",
							"- create a TextureObject for $(file_prefix)_texture_$(buffer_index).png in the graph",
							"  and a new input for texture_$(buffer_index) in the custom node, and connect them",
							"$end_buffers",
							"- copy the shader code below and paste it into the Custom node",
							"*/",
							"struct Functions {",
							"$definitions hlsl,rename_buffers,unreal",
							"\tfixed4 generated_shader(float2 uv, out float metallic, out float roughness, out float3 normal) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tfloat4 _controlled_variation_ = float4(0.0, 0.0, 0.0, 0.0);",
							"$begin_generate hlsl,rename_buffers,unreal",
							"\t\t// sample the generated texture",
							"\t\tfixed4 rv = tofloat4($albedo_tex(uv), 1.0)*$albedo_color;",
							"\t\tmetallic = $metallic_tex(uv)*$metallic;",
							"\t\troughness = $roughness_tex(uv)*$roughness;",
							"\t\tnormal = $normal_tex(uv)*float3(-1.0, -1.0, -1.0)+float3(1.0, 1.0, 1.0);",
							"\t\treturn rv;",
							"$end_generate",
							"\t}",
							"};",
							"Functions f;",
							"fixed4 albedo = f.generated_shader(TexCoords, metallic, roughness, normal);",
							"return albedo;",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					}
				],
				"name": "Unreal/Unreal Engine 4"
			},
			"Unreal/Unreal Engine 5": {
				"export_extension": "py",
				"files": [
					{
						"file_name": "$(path_prefix).py",
						"prompt_overwrite": false,
						"template": [
							"import unreal",
							"import sys",
							"sys.path.append('$(material_maker_path)$(path_separator)export')",
							"import mm",
							"from importlib import reload",
							"reload(mm)",
							"mat = mm.Material('$(file_prefix)', True)",
							"mat.clear()",
							"Custom_0 = mat.add_node('Custom', -264, 80)",
							"Custom_0.set_editor_property('code', mm.read_text_file('$(path_prefix).shader'))",
							"Custom_0.set_editor_property('output_type', unreal.CustomMaterialOutputType.CMOT_FLOAT4)",
							"Custom_0.set_editor_property('additional_outputs', [ mm.custom_output('metallic', 1), mm.custom_output('roughness', 1), mm.custom_output('normal', 3), mm.custom_output('emission', 3)])",
							"inputs = [mm.custom_input('TexCoords'), mm.custom_input('Time')]",
							"$begin_buffers",
							"inputs.append(mm.custom_input('texture_$(buffer_index)'))",
							"$end_buffers",
							"Custom_0.set_editor_property('inputs', inputs)",
							"TextureCoordinate_0 = mat.add_node('TextureCoordinate', -472, 80)",
							"Time_0 = mat.add_node('Time', -456, 180)",
							"$begin_buffers",
							"Texture_$(buffer_index) = mat.add_node('TextureObject', -456, $(expr:110+170*$(buffer_index)))",
							"Texture_$(buffer_index).set_editor_property('texture', mm.import_texture('$(path_prefix)_texture_$(buffer_index).png', '/Game/Textures'))",
							"$end_buffers",
							"mat.connect_property(Custom_0, 'return', unreal.MaterialProperty.MP_BASE_COLOR)",
							"mat.connect_property(Custom_0, 'metallic', unreal.MaterialProperty.MP_METALLIC)",
							"mat.connect_property(Custom_0, 'roughness', unreal.MaterialProperty.MP_ROUGHNESS)",
							"mat.connect_property(Custom_0, 'normal', unreal.MaterialProperty.MP_NORMAL)",
							"mat.connect_property(Custom_0, 'emission', unreal.MaterialProperty.MP_EMISSIVE_COLOR)",
							"mat.connect_nodes(TextureCoordinate_0, '', Custom_0, 'TexCoords')",
							"mat.connect_nodes(Time_0, '', Custom_0, 'Time')",
							"$begin_buffers",
							"mat.connect_nodes(Texture_$(buffer_index), '', Custom_0, 'texture_$(buffer_index)')",
							"$end_buffers",
							"mat.save()",
							""
						],
						"type": "template"
					},
					{
						"file_name": "$(path_prefix)_texture_$(buffer_index).png",
						"type": "buffers"
					},
					{
						"file_name": "$(path_prefix).shader",
						"template": [
							"struct Functions {",
							"\tfloat Time;",
							"$begin_buffers",
							"\tTexture2D texture_$(buffer_index);",
							"\tSamplerState texture_$(buffer_index)Sampler;",
							"$end_buffers",
							"\t",
							"$definitions hlsl_base,rename_buffers,unreal5",
							"\tfixed4 generated_shader(float2 uv, float _time,",
							"$begin_buffers",
							"\t\t\t\t\t\t\tTexture2D _texture_$(buffer_index), SamplerState _texture_$(buffer_index)Sampler,",
							"$end_buffers",
							"\t\t\t\t\t\t\tout float metallic, out float roughness, out float3 normal, out float3 emission) {",
							"\t\tfloat _seed_variation_ = 0.0;",
							"\t\tfloat4 _controlled_variation_ = float4(0.0, 0.0, 0.0, 0.0);",
							"\t\tTime = _time;",
							"$begin_buffers",
							"\t\ttexture_$(buffer_index) = _texture_$(buffer_index);",
							"\t\ttexture_$(buffer_index)Sampler = _texture_$(buffer_index)Sampler;",
							"$end_buffers",
							"\t\t",
							"$begin_generate hlsl_base,rename_buffers,unreal5",
							"\t\t// sample the generated texture",
							"\t\tfixed4 rv = tofloat4($albedo_tex(uv), 1.0)*$albedo_color;",
							"\t\tmetallic = $metallic_tex(uv)*$metallic;",
							"\t\troughness = $roughness_tex(uv)*$roughness;",
							"\t\tnormal = $normal_tex(uv)*float3(-1.0, -1.0, -1.0)+float3(1.0, 1.0, 1.0);",
							"\t\temission = $emission_tex(uv)*$emission_energy;",
							"\t\treturn rv;",
							"$end_generate",
							"\t}",
							"};",
							"Functions f;",
							"fixed4 albedo = f.generated_shader(TexCoords, Time, ",
							"$begin_buffers",
							"\t\t\t\t\t\t\t\t   texture_$(buffer_index), texture_$(buffer_index)Sampler,",
							"$end_buffers",
							"\t\t\t\t\t\t\t\t   metallic, roughness, normal, emission);",
							"return albedo;",
							""
						],
						"type": "template"
					},
					{
						"file_name": "clipboard",
						"template": [
							"\"$(path_prefix).py\"",
							""
						],
						"type": "template"
					}
				],
				"material": "material_dynamic",
				"name": "Unreal/Unreal Engine 5"
			}
		},
		"global": "",
		"inputs": [
			{
				"default": "vec3(1.0)",
				"group_size": 7,
				"label": "",
				"name": "albedo_tex",
				"type": "rgb"
			},
			{
				"default": "1.0",
				"label": "",
				"name": "metallic_tex",
				"type": "f"
			},
			{
				"default": "1.0",
				"label": "",
				"name": "roughness_tex",
				"type": "f"
			},
			{
				"default": "vec3(0.0)",
				"label": "",
				"name": "emission_tex",
				"type": "rgb"
			},
			{
				"default": "vec3(0.5)",
				"label": "",
				"name": "normal_tex",
				"type": "rgb"
			},
			{
				"default": "1.0",
				"label": "",
				"name": "ao_tex",
				"type": "f"
			},
			{
				"default": "0.0",
				"function": true,
				"label": "",
				"name": "depth_tex",
				"type": "f"
			},
			{
				"default": "1.0",
				"label": "",
				"name": "opacity_tex",
				"type": "f"
			}
		],
		"instance": "",
		"name": "Dynamic PBR Material",
		"outputs": [

		],
		"parameters": [
			{
				"default": {
					"a": 1,
					"b": 1,
					"g": 1,
					"r": 1
				},
				"label": "Albedo",
				"name": "albedo_color",
				"type": "color"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Metallic",
				"max": 1,
				"min": 0,
				"name": "metallic",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Roughness",
				"max": 1,
				"min": 0,
				"name": "roughness",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Emission",
				"max": 1,
				"min": 0,
				"name": "emission_energy",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Normal",
				"max": 10,
				"min": 0,
				"name": "normal",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Ambient occlusion",
				"max": 1,
				"min": 0,
				"name": "ao",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.5,
				"label": "Depth",
				"max": 1,
				"min": 0,
				"name": "depth_scale",
				"step": 0.01,
				"type": "float"
			},
			{
				"default": false,
				"label": "Transparency",
				"name": "flags_transparent",
				"type": "boolean"
			}
		],
		"preview_shader": [
			"shader_type spatial;",
			"render_mode blend_mix,cull_back,diffuse_burley,specular_schlick_ggx",
			"$if $(connected:opacity_tex) and $(param:flags_transparent)",
			",depth_draw_opaque",
			"$fi",
			";",
			"",
			"uniform vec3 uv1_offset = vec3(1.0, 1.0, 1.0);",
			"uniform vec3 uv1_scale = vec3(1.0, 1.0, 1.0);",
			"uniform int depth_min_layers = 64;",
			"uniform int depth_max_layers = 64;",
			"uniform vec2 depth_flip = vec2(1.0);",
			"uniform float variation = 0.0;",
			"",
			"varying float elapsed_time;",
			"",
			"void vertex() {",
			"\telapsed_time = TIME;",
			"\tUV = UV*uv1_scale.xy+uv1_offset.xy;",
			"}",
			"",
			"//---",
			"",
			"",
			"$definitions",
			"",
			"void fragment() {",
			"\tfloat _seed_variation_ = variation;",
			"\tvec4 _controlled_variation_ = vec4(0.0);",
			"\tvec2 uv = fract(UV);",
			"",
			"$if $(connected:depth_tex)",
			"\t{",
			"$begin_generate",
			"\t\tfloat depth_scale = 0.2*$depth_scale;",
			"$end_generate",
			"\t\tvec3 view_dir = normalize(normalize(-VERTEX)*mat3(TANGENT*depth_flip.x,-BINORMAL*depth_flip.y,NORMAL));",
			"\t\tfloat num_layers = mix(float(depth_max_layers),float(depth_min_layers), abs(dot(vec3(0.0, 0.0, 1.0), view_dir)));",
			"\t\tfloat layer_depth = 1.0 / num_layers;",
			"\t\tfloat current_layer_depth = 0.0;",
			"\t\tvec2 P = view_dir.xy * depth_scale;",
			"\t\tvec2 delta = P / num_layers;",
			"\t\tvec2  ofs = uv;",
			"$begin_generate",
			"\t\tfloat depth = $depth_tex(ofs);",
			"$end_generate",
			"\t\tfloat current_depth = 0.0;",
			"\t\twhile(current_depth < depth) {",
			"\t\t\tofs -= delta;",
			"$begin_generate",
			"\t\t\tdepth = $depth_tex(ofs);",
			"$end_generate",
			"\t\t\tcurrent_depth += layer_depth;",
			"\t\t}",
			"\t\tvec2 prev_ofs = ofs + delta;",
			"\t\tfloat after_depth  = depth - current_depth;",
			"$begin_generate",
			"\t\tfloat before_depth = $depth_tex(prev_ofs) - current_depth + layer_depth;",
			"$end_generate",
			"\t\tfloat weight = after_depth / (after_depth - before_depth);",
			"\t\tofs = mix(ofs,prev_ofs,weight);",
			"\t\tuv = ofs;",
			"\t}",
			"$fi",
			"$begin_generate",
			"\tvec3 albedo_tex = $albedo_tex(uv);",
			"\talbedo_tex = mix(pow((albedo_tex + vec3(0.055)) * (1.0 / (1.0 + 0.055)),vec3(2.4)),albedo_tex * (1.0 / 12.92),lessThan(albedo_tex,vec3(0.04045)));",
			"\tALBEDO = albedo_tex.rgb*$albedo_color.rgb;",
			"\tMETALLIC = $metallic_tex(uv)*$metallic;",
			"\tROUGHNESS = $roughness_tex(uv)*$roughness;",
			"\tNORMAL_MAP = $normal_tex(uv);",
			"\tNORMAL_MAP_DEPTH = $normal;",
			"\tEMISSION = $emission_tex(uv)*$emission_energy;",
			"\tAO = $ao*$ao_tex(uv);",
			"$if $(connected:opacity_tex) and $(param:flags_transparent)",
			"\tALPHA = $opacity_tex(uv);",
			"$fi",
			"$end_generate",
			"}",
			""
		]
	},
	"type": "material_export"
}
