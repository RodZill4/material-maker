{
	"name": "fbm3",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"folds": 0,
		"iterations": 5,
		"noise": 9,
		"offset": 0,
		"persistence": 0.5,
		"scale_x": 2,
		"scale_y": 2
	},
	"seed_int": 0,
	"shader_model": {
		"code": "",
		"global": [
			"float value_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat p00 = rand(mod(o, size));",
			"\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));",
			"\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));",
			"\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));",
			"\tp00 = sin(p00 * 6.28318530718 + offset * 6.28318530718) / 2.0 + 0.5;",
			"\tp01 = sin(p01 * 6.28318530718 + offset * 6.28318530718) / 2.0 + 0.5;",
			"\tp10 = sin(p10 * 6.28318530718 + offset * 6.28318530718) / 2.0 + 0.5;",
			"\tp11 = sin(p11 * 6.28318530718 + offset * 6.28318530718) / 2.0 + 0.5;",
			"\tvec2 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);",
			"\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);",
			"}",
			"",
			"float fbm_2d_value(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = value_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float perlin_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat a00 = rand(mod(o, size)) * 6.28318530718 + offset * 6.28318530718;",
			"\tfloat a01 = rand(mod(o + vec2(0.0, 1.0), size)) * 6.28318530718 + offset * 6.28318530718;",
			"\tfloat a10 = rand(mod(o + vec2(1.0, 0.0), size)) * 6.28318530718 + offset * 6.28318530718;",
			"\tfloat a11 = rand(mod(o + vec2(1.0, 1.0), size)) * 6.28318530718 + offset * 6.28318530718;",
			"\tvec2 v00 = vec2(cos(a00), sin(a00));",
			"\tvec2 v01 = vec2(cos(a01), sin(a01));",
			"\tvec2 v10 = vec2(cos(a10), sin(a10));",
			"\tvec2 v11 = vec2(cos(a11), sin(a11));",
			"\tfloat p00 = dot(v00, f);",
			"\tfloat p01 = dot(v01, f - vec2(0.0, 1.0));",
			"\tfloat p10 = dot(v10, f - vec2(1.0, 0.0));",
			"\tfloat p11 = dot(v11, f - vec2(1.0, 1.0));",
			"\tvec2 t =  f * f * f * (f * (f * 6.0 - 15.0) + 10.0);",
			"\treturn 0.5 + mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);",
			"}",
			"",
			"float fbm_2d_perlin(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = perlin_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float perlinabs_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\treturn abs(2.0*perlin_noise_2d(coord, size, offset, seed)-1.0);",
			"}",
			"",
			"float fbm_2d_perlinabs(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = perlinabs_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float fbm_2d_mod289(float x) {",
			"\treturn x - floor(x * (1.0 / 289.0)) * 289.0;",
			"}",
			"",
			"float fbm_2d_permute(float x) {",
			"\treturn fbm_2d_mod289(((x * 34.0) + 1.0) * x);",
			"}",
			"",
			"vec2 fbm_2d_rgrad2(vec2 p, float rot, float seed) {",
			"\tfloat u = fbm_2d_permute(fbm_2d_permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift",
			"\tu = fract(u) * 6.28318530718; // 2*pi",
			"\treturn vec2(cos(u), sin(u));",
			"}",
			"",
			"float simplex_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tcoord *= 2.0; // needed for it to tile",
			"\tcoord += rand2(vec2(seed, 1.0-seed)) + size;",
			"\tsize *= 2.0; // needed for it to tile",
			"\tcoord.y += 0.001;",
			"\tvec2 uv = vec2(coord.x + coord.y*0.5, coord.y);",
			"\tvec2 i0 = floor(uv);",
			"\tvec2 f0 = fract(uv);",
			"\tvec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",
			"\tvec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);",
			"\tvec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);",
			"\tvec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);",
			"\ti1 = i0 + i1;",
			"\tvec2 i2 = i0 + vec2(1.0, 1.0);",
			"\tvec2 d0 = coord - p0;",
			"\tvec2 d1 = coord - p1;",
			"\tvec2 d2 = coord - p2;",
			"\tvec3 xw = mod(vec3(p0.x, p1.x, p2.x), size.x);",
			"\tvec3 yw = mod(vec3(p0.y, p1.y, p2.y), size.y);",
			"\tvec3 iuw = xw + 0.5 * yw;",
			"\tvec3 ivw = yw;",
			"\tvec2 g0 = fbm_2d_rgrad2(vec2(iuw.x, ivw.x), offset, seed);",
			"\tvec2 g1 = fbm_2d_rgrad2(vec2(iuw.y, ivw.y), offset, seed);",
			"\tvec2 g2 = fbm_2d_rgrad2(vec2(iuw.z, ivw.z), offset, seed);",
			"\tvec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));",
			"\tvec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));",
			"\tt = max(t, vec3(0.0));",
			"\tvec3 t2 = t * t;",
			"\tvec3 t4 = t2 * t2;",
			"\tfloat n = dot(t4, w);",
			"\treturn 0.5 + 5.5 * n;",
			"}",
			"",
			"float fbm_2d_simplex(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = simplex_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode =  0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718 * node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = length(diff);",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float fbm_2d_cellular(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular2_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode = 0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718*node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = length(diff);",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			"",
			"float fbm_2d_cellular2(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular2_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular3_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode = 0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718*node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = abs((diff).x) + abs((diff).y);",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float fbm_2d_cellular3(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular3_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular4_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode = 0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718*node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = abs((diff).x) + abs((diff).y);",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			"",
			"float fbm_2d_cellular4(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular4_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular5_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode = 0.5 + 0.5 * sin(offset * 6.28318530718 + 6.28318530718*node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = max(abs((diff).x), abs((diff).y));",
			"\t\t\tmin_dist = min(min_dist, dist);",
			"\t\t}",
			"\t}",
			"\treturn min_dist;",
			"}",
			"",
			"float fbm_2d_cellular5(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular5_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"float cellular6_noise_2d(vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 o = floor(coord)+rand2(vec2(seed, 1.0-seed))+size;",
			"\tvec2 f = fract(coord);",
			"\tfloat min_dist1 = 2.0;",
			"\tfloat min_dist2 = 2.0;",
			"\tfor(float x = -1.0; x <= 1.0; x++) {",
			"\t\tfor(float y = -1.0; y <= 1.0; y++) {",
			"\t\t\tvec2 neighbor = vec2(float(x),float(y));",
			"\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);",
			"\t\t\tnode = 0.5 + 0.25 * sin(offset * 6.28318530718 + 6.28318530718*node);",
			"\t\t\tvec2 diff = neighbor + node - f;",
			"\t\t\tfloat dist = max(abs((diff).x), abs((diff).y));",
			"\t\t\tif (min_dist1 > dist) {",
			"\t\t\t\tmin_dist2 = min_dist1;",
			"\t\t\t\tmin_dist1 = dist;",
			"\t\t\t} else if (min_dist2 > dist) {",
			"\t\t\t\tmin_dist2 = dist;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn min_dist2-min_dist1;",
			"}",
			"",
			"float fbm_2d_cellular6(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = cellular6_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			"",
			"// MIT License Inigo Quilez - https://www.shadertoy.com/view/Xd23Dh",
			"float voronoise_noise_2d( vec2 coord, vec2 size, float offset, float seed) {",
			"\tvec2 i = floor(coord) + rand2(vec2(seed, 1.0-seed)) + size;",
			"\tvec2 f = fract(coord);",
			"\t",
			"\tvec2 a = vec2(0.0);",
			"\t",
			"\tfor( int y=-2; y<=2; y++ ) {",
			"\t\tfor( int x=-2; x<=2; x++ ) {",
			"\t\t\tvec2  g = vec2( float(x), float(y) );",
			"\t\t\tvec3  o = rand3( mod(i + g, size) + vec2(seed) );",
			"\t\t\to.xy += 0.25 * sin(offset * 6.28318530718 + 6.28318530718*o.xy);",
			"\t\t\tvec2  d = g - f + o.xy;",
			"\t\t\tfloat w = pow( 1.0-smoothstep(0.0, 1.414, length(d)), 1.0 );",
			"\t\t\ta += vec2(o.z*w,w);",
			"\t\t}",
			"\t}",
			"\t",
			"\treturn a.x/a.y;",
			"}",
			"",
			"float fbm_2d_voronoise(vec2 coord, vec2 size, int folds, int octaves, float persistence, float offset, float seed) {",
			"\tfloat normalize_factor = 0.0;",
			"\tfloat value = 0.0;",
			"\tfloat scale = 1.0;",
			"\tfor (int i = 0; i < octaves; i++) {",
			"\t\tfloat noise = voronoise_noise_2d(coord*size, size, offset, seed+float(i));",
			"\t\tfor (int f = 0; f < folds; ++f) {",
			"\t\t\tnoise = abs(2.0*noise-1.0);",
			"\t\t}",
			"\t\tvalue += noise * scale;",
			"\t\tnormalize_factor += scale;",
			"\t\tsize *= 2.0;",
			"\t\tscale *= persistence;",
			"\t}",
			"\treturn value / normalize_factor;",
			"}",
			""
		],
		"inputs": [
			{
				"default": "$offset",
				"label": "7:",
				"longdesc": "An optional input to drive the offset",
				"name": "offset_in",
				"shortdesc": "Offset Input",
				"type": "f"
			}
		],
		"instance": "",
		"longdesc": "Generates a noise made of several octaves of a simple noise",
		"name": "FBM Noise",
		"outputs": [
			{
				"f": "fbm_2d_$noise($(uv), vec2($(scale_x), $(scale_y)), int($(folds)), int($(iterations)), $(persistence), $offset_in($uv), $(seed))",
				"longdesc": "Shows a greyscale image of the generated noise",
				"shortdesc": "Output",
				"type": "f"
			}
		],
		"parameters": [
			{
				"default": 2,
				"label": "Noise",
				"longdesc": "The simple noise type",
				"name": "noise",
				"shortdesc": "Noise type",
				"type": "enum",
				"values": [
					{
						"name": "Value",
						"value": "value"
					},
					{
						"name": "Perlin",
						"value": "perlin"
					},
					{
						"name": "Simplex",
						"value": "simplex"
					},
					{
						"name": "Cellular",
						"value": "cellular"
					},
					{
						"name": "Cellular 2",
						"value": "cellular2"
					},
					{
						"name": "Cellular 3",
						"value": "cellular3"
					},
					{
						"name": "Cellular 4",
						"value": "cellular4"
					},
					{
						"name": "Cellular 5",
						"value": "cellular5"
					},
					{
						"name": "Cellular 6",
						"value": "cellular6"
					},
					{
						"name": "Voronoise",
						"value": "voronoise"
					}
				]
			},
			{
				"control": "None",
				"default": 4,
				"label": "Scale X",
				"longdesc": "The scale of the first octave along the X axis",
				"max": 32,
				"min": 1,
				"name": "scale_x",
				"shortdesc": "Scale.x",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 4,
				"label": "Scale Y",
				"longdesc": "The scale of the first octave along the Y axis",
				"max": 32,
				"min": 1,
				"name": "scale_y",
				"shortdesc": "Scale.y",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0,
				"label": "Folds",
				"longdesc": "The number of times the basic noise is folded",
				"max": 5,
				"min": 0,
				"name": "folds",
				"shortdesc": "Folds",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 3,
				"label": "Iterations",
				"longdesc": "The number of noise octaves",
				"max": 10,
				"min": 1,
				"name": "iterations",
				"shortdesc": "Octaves",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.5,
				"label": "Persistence",
				"longdesc": "The persistence between two consecutive octaves",
				"max": 1,
				"min": 0,
				"name": "persistence",
				"shortdesc": "Persistence",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0,
				"label": "Offset",
				"longdesc": "Offsets the points of the noise, can be used to animate the noise with \"$time\"",
				"max": 1,
				"min": 0,
				"name": "offset",
				"shortdesc": "Offset",
				"step": 0.01,
				"type": "float"
			}
		],
		"shortdesc": "Fractional Brownian Motion Noise"
	},
	"type": "shader"
}