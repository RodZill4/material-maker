{
	"name": "skewed_bricks",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"bevel": 0.1,
		"columns": 3,
		"corner": 0.3,
		"mortar": 0.1,
		"offset": 0.5,
		"randomness": 1,
		"round": 0,
		"rows": 6
	},
	"seed_int": 1630837737,
	"shader_model": {
		"code": [
			"vec3 $(name_uv)_brick_uv;",
			"vec3 $(name_uv)_corner_uv;",
			"vec4 $(name_uv)_brick_fill;",
			"vec4 $(name_uv)_corner_fill;",
			"float $(name_uv)_bricks = skewed_bricks($uv, vec2($columns, $rows), $offset, $randomness, $mortar * $mortar_map($uv), $bevel * $bevel_map($uv), $round * $round_map($uv), $corner, $seed, $(name_uv)_brick_uv, $(name_uv)_corner_uv, $(name_uv)_brick_fill, $(name_uv)_corner_fill);"
		],
		"global": [
			"float skewed_brick_rand(vec2 x) {",
			"\t// To avoid weird precission errors I was having",
			"\tx *= 4096.0;",
			"\tx = round(x);",
			"\treturn rand(x);",
			"}",
			"",
			"vec2 perpendicular(vec2 vector) {",
			"\tvector = vector.yx;",
			"\tvector.y = -vector.y;",
			"\treturn vector;",
			"}",
			"",
			"// https://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point",
			"// Copyright 2001, softSurfer (www.softsurfer.com); 2008, LSL-port by Nexii Malthus",
			"// (CC BY-SA 3.0 License)",
			"vec2 get_line_intersection(vec4 line1, vec4 line2) {",
			"\tvec2 A = line1.xy;",
			"\tvec2 B = line1.zw;",
			"\tvec2 C = line2.xy;",
			"\tvec2 D = line2.zw;",
			"\t",
			"\tvec2 b = B - A;",
			"\tvec2 d = D - C;",
			"\tfloat dotperp = b.x * d.y - b.y * d.x;",
			"\t// if I had to worry about parallel lines, but I shouldn't have to here",
			"\t// if (dotperp == 0) return <-1,-1,-1>;",
			"\tvec2 c = C - A;",
			"\tfloat t = (c.x * d.y - c.y * d.x) / dotperp;",
			"\treturn vec2(A.x + t * b.x, A.y + t * b.y);",
			"}",
			"",
			"float skewed_bricks(vec2 uv, vec2 scale, float offset, float randomness, float mortar, float bevel, float round_radius, float corner, float seed, inout vec3 brick_uv, inout vec3 corner_uv, inout vec4 brick_fill, inout vec4 corner_fill) {",
			"\t// rb2",
			"\t//scale.x *= 1.0 + step(0.5, fract(uv.y * scale.y * 0.5));",
			"\t",
			"\tvec2 scaled_uv = uv * scale;",
			"\t",
			"\tfloat x_offset = offset * step(0.5, fract(uv.y * scale.y * 0.5));",
			"\t\t",
			"\tvec2 cell_id = floor(scaled_uv);",
			"\tvec2 cell_uv = fract(scaled_uv);",
			"\t",
			"\tcell_id -= vec2(x_offset, 0.0);",
			"\t",
			"\tfloat min_distance = 1.0;",
			"\tvec2 c_point;",
			"\tvec2 left_top;",
			"\tvec2 right_top;",
			"\tvec2 right_bottom;",
			"\tvec2 left_bottom;",
			"\t",
			"\tfor (int i = -1; i <= 1; i++) {",
			"\t\t// neighbor in uv space",
			"\t\tvec2 neighbor = vec2(float(i), 0.0);",
			"\t\tvec2 point = cell_id + neighbor + vec2(0.5) + (vec2(0.0, skewed_brick_rand(mod(cell_id + neighbor + seed, scale)) - 0.5) * randomness * scale.y / 4.0);",
			"\t\tpoint /= scale;",
			"\t\tfloat dist = distance(point, uv);",
			"\t\t",
			"\t\t// get left, right neighbor in here as well, to calculate perpendicular and intersect",
			"\t\tvec2 left = cell_id + neighbor + vec2(-1.0, 0.0) + vec2(0.5) + (vec2(0.0, skewed_brick_rand(mod(cell_id + neighbor + vec2(-1.0, 0.0) + seed, scale)) - 0.5) * randomness * scale.y / 4.0);",
			"\t\tleft /= scale;",
			"\t\tvec2 right = cell_id + neighbor + vec2(1.0, 0.0) + vec2(0.5) + (vec2(0.0, skewed_brick_rand(mod(cell_id + neighbor + vec2(1.0, 0.0) + seed, scale)) - 0.5) * randomness * scale.y / 4.0);",
			"\t\tright /= scale;",
			"\t\t",
			"\t\t// Find the midpoint between current and left and a vector perpendicular to the vector between the two points",
			"\t\tvec2 left_midpoint = (left + point) / 2.0;",
			"\t\tvec2 left_perpendicular = perpendicular(point - left);",
			"\t\tvec2 left_2 = left_midpoint + left_perpendicular;",
			"\t\t// Do the same for midpoint to right point",
			"\t\tvec2 right_midpoint = (point + right) / 2.0;",
			"\t\tvec2 right_perpendicular = perpendicular(right - point);",
			"\t\tvec2 right_2 = right_midpoint + right_perpendicular;",
			"\t\t",
			"\t\tif (dist < min_distance) {",
			"\t\t\tmin_distance = dist;",
			"\t\t\tc_point = point;",
			"\t\t\tleft_top = get_line_intersection(vec4(left_midpoint, left_2), vec4(cell_id / scale, cell_id / scale + vec2(1.0, 0.0)));",
			"\t\t\tright_top = get_line_intersection(vec4(right_midpoint, right_2), vec4(cell_id / scale, cell_id / scale + vec2(1.0, 0.0)));",
			"\t\t\tright_bottom = get_line_intersection(vec4(right_midpoint, right_2), vec4((cell_id + 1.0) / scale, (cell_id + 1.0) / scale + vec2(1.0, 0.0)));",
			"\t\t\tleft_bottom = get_line_intersection(vec4(left_midpoint, left_2), vec4((cell_id + 1.0) / scale, (cell_id + 1.0) / scale + vec2(1.0, 0.0)));",
			"\t\t}",
			"\t}",
			"",
			"\t// The bricks skewed uv.x gradient",
			"\tfloat grad = (uv.x - mix(left_top.x, left_bottom.x, cell_uv.y)) / mix(right_top.x - left_top.x, right_bottom.x - left_bottom.x, cell_uv.y);",
			"\t",
			"\tbrick_uv = vec3(grad, cell_uv.y, skewed_brick_rand(fract(c_point)));",
			"\t",
			"\tcorner_uv.xy = scale.yx / corner / 8.0 * (1.0 - (2.0 * abs(brick_uv.xy - 0.5)));",
			"\tcorner_uv.x = brick_uv.x < 0.5 ? corner_uv.x : 1.0 - corner_uv.x;",
			"\tcorner_uv.y = brick_uv.y < 0.5 ? corner_uv.y : 1.0 - corner_uv.y;",
			"\tcorner_uv.z = skewed_brick_rand( floor(brick_uv.xy * 2.0) + fract(c_point) );",
			"\t",
			"\t// Calculate bounding box",
			"\tbrick_fill.x = min(left_top.x, left_bottom.x);",
			"\tbrick_fill.y = min(left_top.y, right_top.y);",
			"\tbrick_fill.z = max(right_top.x, right_bottom.x);",
			"\tbrick_fill.z = brick_fill.z - brick_fill.x;",
			"\tbrick_fill.w = 1.0 / scale.y;",
			"\tbrick_fill.xy = fract(brick_fill.xy);",
			"\t// Calculate corner bounding box",
			"\tfloat half_corner_size = 1.0 / scale.y * corner * 0.5;",
			"\tvec2 top_centers = brick_uv.x < 0.5 ? left_top + (normalize(left_bottom - left_top) + vec2(1.0, 0.0)) * half_corner_size : right_top + (normalize(right_bottom - right_top) - vec2(1.0, 0.0)) * half_corner_size; ",
			"\tvec2 bottom_centers = brick_uv.x < 0.5 ? left_bottom + (normalize(left_top - left_bottom) + vec2(1.0, 0.0)) * half_corner_size : right_bottom + (normalize(right_top - right_bottom) - vec2(1.0, 0.0)) * half_corner_size; ",
			"\tcorner_fill.xy = brick_uv.y < 0.5 ? top_centers : bottom_centers;",
			"\tcorner_fill.xy -= half_corner_size;",
			"\tcorner_fill.zw = vec2(half_corner_size * 2.0);",
			"\tcorner_fill = fract(corner_fill);",
			"\tcorner_fill *= 4096.0;",
			"\tcorner_fill = round(corner_fill);",
			"\tcorner_fill /= 4096.0;",
			"\t// Round values to avoid precission errors",
			"\tbrick_fill *= 4096.0;",
			"\tbrick_fill = round(brick_fill);",
			"\tbrick_fill /= 4096.0;",
			"\t",
			"\t// Render the brick",
			"\tfloat brick_height = 1.0 / scale.y;",
			"\tround_radius /= brick_height;",
			"\tmortar /= brick_height;",
			"\tbevel /= brick_height;",
			"\t",
			"\tfloat color;",
			"\tvec2 d = (min(brick_uv.xy, 1.0 - brick_uv.xy) * -2.0)*scale.yx+vec2(round_radius+mortar);",
			"\tcolor = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round_radius;",
			"\tcolor = clamp(-color/bevel, 0.0, 1.0);",
			"\t",
			"\treturn color;",
			"}"
		],
		"inputs": [
			{
				"default": "1.0",
				"label": "5:",
				"longdesc": "A map that affects the Mortar parameter",
				"name": "mortar_map",
				"shortdesc": "Mortar Map",
				"type": "f"
			},
			{
				"default": "1.0",
				"label": "",
				"longdesc": "A map that affects the Bevel parameter",
				"name": "bevel_map",
				"shortdesc": "Bevel Map",
				"type": "f"
			},
			{
				"default": "1.0",
				"label": "",
				"longdesc": "A map that affects the Round parameter",
				"name": "round_map",
				"shortdesc": "Round Map",
				"type": "f"
			}
		],
		"instance": "",
		"longdesc": "Generates running bond bricks patterns where the vertical cuts are skewed.",
		"name": "Skewed Bricks",
		"outputs": [
			{
				"f": "$(name_uv)_bricks",
				"longdesc": "A greyscale image that shows the bricks pattern",
				"shortdesc": "Bricks Pattern",
				"type": "f"
			},
			{
				"longdesc": "A UV layout that exactly matches the skewed brick, use this output with the Custom UV node.",
				"rgb": "$(name_uv)_brick_uv",
				"shortdesc": "Skewed Bricks UV",
				"type": "rgb"
			},
			{
				"longdesc": "A UV layout that exactly matches the skewed brick's corners, use this output with the Custom UV node. For a perfectly square corner uv, use the Corner Fill output and Fill to UV node.",
				"rgb": "$(name_uv)_corner_uv",
				"shortdesc": "Skewed Corner UV",
				"type": "rgb"
			},
			{
				"fill": "$(name_uv)_brick_fill",
				"longdesc": "An output that should be plugged into a Fill companion node",
				"shortdesc": "Brick Fill",
				"type": "fill"
			},
			{
				"fill": "$(name_uv)_corner_fill",
				"longdesc": "An output that should be plugged into a Fill companion node",
				"shortdesc": "Corner Fill",
				"type": "fill"
			}
		],
		"parameters": [
			{
				"control": "None",
				"default": 6,
				"label": "Rows",
				"longdesc": "The number of rows of a pattern",
				"max": 64,
				"min": 0,
				"name": "rows",
				"shortdesc": "Rows",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 3,
				"label": "Columns",
				"longdesc": "The number of columns of a pattern",
				"max": 64,
				"min": 0,
				"name": "columns",
				"shortdesc": "Columns",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.5,
				"label": "Offset",
				"longdesc": "The offset of the pattern",
				"max": 1,
				"min": 0,
				"name": "offset",
				"shortdesc": "Offset",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Randomness",
				"longdesc": "The randomness of the pattern",
				"max": 1,
				"min": 0,
				"name": "randomness",
				"shortdesc": "Randomness",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.1,
				"label": "Mortar",
				"longdesc": "The width of the space between bricks",
				"max": 1,
				"min": 0,
				"name": "mortar",
				"shortdesc": "Mortar",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.1,
				"label": "Bevel",
				"longdesc": "The width of the edge of each brick",
				"max": 1,
				"min": 0,
				"name": "bevel",
				"shortdesc": "Bevel",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0,
				"label": "Round",
				"longdesc": "The radius of the round corners of bricks",
				"max": 1,
				"min": 0,
				"name": "round",
				"shortdesc": "Round",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.3,
				"label": "Corner",
				"longdesc": "The size of the corner part of each brick (only used to calculate the Corner UV and Corner Fill outputs)",
				"max": 1,
				"min": 0,
				"name": "corner",
				"shortdesc": "Corner",
				"step": 0.01,
				"type": "float"
			}
		],
		"shortdesc": "Skewed Bricks"
	},
	"type": "shader"
}