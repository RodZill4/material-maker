{
	"name": "voronoi_triangle",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {
		"randomness": 0.85,
		"scale_x": 4,
		"scale_y": 4,
		"stretch_x": 1,
		"stretch_y": 1
	},
	"seed_int": 1479392895,
	"shader_model": {
		"code": "mat3 $(name_uv)_m3 = tri_voronoi($uv, vec2($scale_x, $scale_y), vec2($stretch_y,$stretch_x), $randomness, $seed);",
		"global": [
			"// Based on https://www.shadertoy.com/view/ss3fW4",
			"const float s3 = 0.866025;",
			"",
			"vec3 sdTriEdges(vec2 p) {",
			"\treturn vec3(",
			"\t\tdot(p, vec2(0,-1)),",
			"\t\tdot(p, vec2(s3, 0.5)),",
			"\t\tdot(p, vec2(-s3, 0.5))",
			"\t);",
			"}",
			"",
			"float sdTri(vec2 p) {",
			"\tvec3 t = sdTriEdges(p);",
			"\treturn max(t.x, max(t.y, t.z));",
			"}",
			"",
			"vec3 primaryAxis(vec3 p) {",
			"\tvec3 a = abs(p);",
			"\treturn (1.0-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);",
			"}",
			"",
			"vec3 sdgBorder(vec2 pt1, vec2 pt2) {\t",
			"\tvec3 tbRel = sdTriEdges(pt2 - pt1);\t",
			"\tvec3 axis = primaryAxis(tbRel);",
			"\t",
			"\tvec2 gA = vec2(0,-1);",
			"\tvec2 gB = vec2(s3, 0.5);",
			"\tvec2 gC = vec2(-s3, 0.5);",
			"\t\t   ",
			"\tvec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;",
			"\tvec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;",
			"   ",
			"\tvec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;",
			"\tvec2 corner = dir * dot(dir, pt1 - pt2) * 2.0/3.0;",
			"\t\t",
			"\tmat2 r90 = mat2(vec2(0.0,-1.0),vec2(1.0,0.0));",
			"\t",
			"\tbool isEdge = axis.x + axis.y + axis.z < 0.0;",
			"\t\t",
			"\tif (isEdge) {",
			"\t\tcorner = pt2 + corner;",
			"\t\tvec2 ca = corner + min(0.0, dot(corner, -norA)) * norA;",
			"\t\tvec2 cb = corner + max(0.0, dot(corner, -norB)) * norB;",
			"\t\tfloat side = step(dot(corner, dir * r90), 0.0);",
			"\t\tcorner = mix(cb, ca, side);",
			"\t} else {",
			"\t\tcorner = pt1 - corner;",
			"\t\tvec2 ca = corner + max(0.0, dot(corner, -norA)) * norA;",
			"\t\tvec2 cb = corner + min(0.0, dot(corner, -norB)) * norB;",
			"\t\tfloat side = step(dot(corner, dir * r90), 0.0);",
			"\t\tcorner = mix(ca, cb, side);",
			"\t}",
			"\t",
			"\tvec2 nor = normalize(corner);",
			"\tfloat d = length(corner);",
			"\treturn vec3(abs(d), nor);",
			"}",
			"",
			"float vmax(vec3 v) { return max(v.x, max(v.y, v.z)); }",
			"",
			"vec4 cellPoint(vec2 n, vec2 f, vec2 cell, float r, float seed, vec2 s, vec2 st) {",
			"\tvec2 coord = n + cell;",
			"\tvec2 o = r*rand2(seed + mod(n + cell + s, s));",
			"\tvec2 point = cell + o - f;",
			"\tpoint *= st;",
			"\treturn vec4(point, coord);",
			"}",
			"",
			"vec2 tri_coord(vec2 x, vec2 s, vec2 st, float r, float seed) {",
			"\tvec2 n = floor(x);",
			"\tvec2 f = fract(x);",
			"",
			"\tvec2 closestCoord;",
			"",
			"\tconst int reach = 2;",
			"\tfloat closestDist = 8.0;",
			"\tfor( int j = -reach; j <= reach; j++ )",
			"\tfor( int i = -reach; i <= reach; i++ )",
			"\t{",
			"\t\tvec2 cell = vec2(float(i), float(j));",
			"\t\tvec4 point = cellPoint(n,f,cell,r,seed,s,st);",
			"\t\t",
			"\t\tfloat dist = vmax(sdTriEdges(point.xy));",
			"",
			"\t\tif( vmax(sdTriEdges(point.xy)) < closestDist )",
			"\t\t{",
			"\t\t\tclosestDist = dist;",
			"\t\t\tclosestCoord = point.zw;",
			"\t\t}",
			"\t}",
			"\treturn closestCoord;",
			"}",
			"",
			"mat3 tri_voronoi( vec2 x, vec2 s, vec2 st, float r, float seed) {\t",
			"\tx *= s;",
			"\tvec2 n = floor(x);",
			"\tvec2 f = fract(x);",
			"",
			"\tvec2 closestCell, closestPoint, nor;",
			"",
			"\tconst int reach = 3;",
			"\tfloat closestDist = 8.0;",
			"\t",
			"\tfor( int j = -reach; j <= reach; j++ )",
			"\tfor( int i = -reach; i <= reach; i++ )",
			"\t{",
			"\t\tvec2 cell = vec2(float(i), float(j));",
			"\t\tvec2 point = cellPoint(n,f,cell,r,seed,s,st).xy;",
			"",
			"\t\tfloat dist = sdTri(point);",
			"",
			"\t\tif( dist < closestDist )",
			"\t\t{",
			"\t\t\tclosestDist = dist;",
			"\t\t\tclosestPoint = point;",
			"\t\t\tclosestCell = cell;",
			"\t\t}",
			"\t}",
			"",
			"\tclosestDist = 8.0;",
			"\tfor( int j = -reach-1; j <= reach+1; j++ )",
			"\tfor( int i = -reach-1; i <= reach+1; i++ )",
			"\t{",
			"\t\tvec2 cell = closestCell + vec2(float(i), float(j));",
			"\t\tvec2 coord = n + cell;",
			"\t\t\tvec2 o = r*rand2(seed + mod(n + cell + s, s));",
			"\t\t\tvec2 point = cell + o - f;",
			"\t\tpoint *= st;",
			"",
			"\t\tfloat dist = sdTri(closestPoint - point);",
			"\t\t",
			"\t\tif( dist > 0.00001 ) {",
			"\t\t\tvec3 sdg = sdgBorder(closestPoint, point);",
			"\t\t\tif (sdg.x < closestDist) {",
			"\t\t\t\tclosestDist = sdg.x;",
			"\t\t\t\tnor = sdg.zy;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\treturn mat3(",
			"\t\tvec3(closestDist,closestPoint),",
			"\t\tvec3(nor,0),",
			"\t\tvec3(tri_coord(x,s,st,r,seed),0));",
			"}"
		],
		"inputs": [

		],
		"instance": "",
		"longdesc": "Generates several images from a tileable voronoi noise",
		"name": "Triangle Voronoi",
		"outputs": [
			{
				"f": "length($(name_uv)_m3[0].yz)",
				"longdesc": "A greyscale pattern based on the distance to cell centers",
				"shortdesc": "Nodes",
				"type": "f"
			},
			{
				"f": "$(name_uv)_m3[0].x",
				"longdesc": "A greyscale pattern based on the distance to borders",
				"shortdesc": "Border",
				"type": "f"
			},
			{
				"longdesc": "Shows a random color for each cell",
				"rgb": "rand3(fract($(name_uv)_m3[2].xy/vec2($scale_x,$scale_y)))",
				"shortdesc": "Random color",
				"type": "rgb"
			},
			{
				"longdesc": "Shows an UV map to be connected to the UV map port of the Custom UV node",
				"rgb": "vec3(-$(name_uv)_m3[0].yz*0.5+0.5,rand(fract($(name_uv)_m3[2].xy/vec2($scale_x,$scale_y))))",
				"shortdesc": "UV Map",
				"type": "rgb"
			},
			{
				"longdesc": "Generated normal map",
				"rgb": "vec3(0.5)+0.5*normalize(vec3(vec2(-$(name_uv)_m3[1].y,-$(name_uv)_m3[1].x), -1.0))",
				"shortdesc": "Normal Map",
				"type": "rgb"
			}
		],
		"parameters": [
			{
				"control": "None",
				"default": 4,
				"label": "Scale X",
				"longdesc": "The scale along the X axis",
				"max": 32,
				"min": 1,
				"name": "scale_x",
				"shortdesc": "Scale.x",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 4,
				"label": "Scale Y",
				"longdesc": "The scale along the Y axis",
				"max": 32,
				"min": 1,
				"name": "scale_y",
				"shortdesc": "Scale.y",
				"step": 1,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Stretch X",
				"longdesc": "The stretch factor along the X axis",
				"max": 1,
				"min": 0,
				"name": "stretch_x",
				"shortdesc": "Stretch.x",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 1,
				"label": "Stretch Y",
				"longdesc": "The stretch factor along the Y axis",
				"max": 1,
				"min": 0,
				"name": "stretch_y",
				"shortdesc": "Stretch.y",
				"step": 0.01,
				"type": "float"
			},
			{
				"control": "None",
				"default": 0.85,
				"label": "Randomness",
				"longdesc": "The randomness of cell centers positions",
				"max": 1,
				"min": 0,
				"name": "randomness",
				"shortdesc": "Randomness",
				"step": 0.01,
				"type": "float"
			}
		],
		"shortdesc": "Triangle voronoi noise"
	},
	"type": "shader"
}